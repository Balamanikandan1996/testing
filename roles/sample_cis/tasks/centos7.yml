---
####DEPENDENCY PACKAGE####
  - name: install pip2
    yum: name=python-pip state=present
    ignore_errors: True
    when: ansible_python_version <= "3.0.0"
    tags:
      - bootloadpass
      - 1.5.1
      - one
      - all

  - name: install pip2 package[pexpect]
    pip:
      name: pexpect
    ignore_errors: True
    when: ansible_python_version <= "3.0.0"
    tags:
      - bootloadpass
      - 1.5.1
      - one
      - all

  - name: check if pexpect package available
    shell: (pip3 search pexpect | grep INSTALLED | wc -l)
    register: check_pexpect
    ignore_errors: yes
    when: ansible_python_version >= "3.0.0"
    tags:
      - bootloadpass
      - 1.5.1
      - one
      - all

  - name: install pip3 package[pexpect]
    pip:
      name: pexpect
    ignore_errors: True
    when:
    - ansible_python_version >= "3.0.0"
    - check_pexpect.stdout == "0"
    tags:
      - bootloadpass
      - 1.5.1
      - one
      - all

  - name: install net-tools
    yum: name=net-tools state=present
    failed_when: no
    tags:
      - firewallrules
      - 3.5.3.2.4
      - three
      - all

####REMEDY####
  - name: Create /etc/modprobe.d with root ownership 
    file: path=/etc/modprobe.d state=touch owner=root group=root mode=0600
    changed_when: false
    tags:
      - cramfs
      - 1.1.1.1
      - squashfs
      - 1.1.1.2
      - udf
      - 1.1.1.3
      - fat
      - 1.1.1.4
      - dccp
      - 3.4.1
      - sctp
      - 3.4.2
      - all  

  - name: 1.1.1.1-Fetch the cramfs value from ansible facts
    shell: echo "{{ ansible_local.cramfs_1111_audit }}" 
    register: cramfs
    ignore_errors: True
    tags:
      - cramfs
      - 1.1.1.1
      - one
      - all

  - name: 1.1.1.1 - Ensure mounting of cramfs filesystems is disabled
    lineinfile:
      path: /etc/modprobe.d/cramfs.conf
      line: "install cramfs /bin/true"
      state: present
      create: yes
    when: cramfs.stdout.find("FAILED") != -1
    tags:
      - cramfs
      - 1.1.1.1
      - one
      - all
      
  - name: 1.1.1.1 - Ensure mounting of cramfs filesystems is disabled
    shell: "rmmod cramfs"
    failed_when: no
    when: cramfs.stdout.find("FAILED") != -1
    tags:
      - cramfs
      - 1.1.1.1
      - one
      - all
      
  - name: 1.1.1.2-Fetch the squashfs  value from ansible facts
    shell: echo "{{ ansible_local.squashfs_1112_audit }}" 
    register: squashfs
    ignore_errors: True
    tags:
      - squashfs
      - 1.1.1.2
      - one
      - all

  - name: 1.1.1.2 - Ensure mounting of squashfs filesystem is disabled
    lineinfile:
      path: /etc/modprobe.d/squashfs.conf
      line: "install squashfs /bin/true"
      state: present
      create: yes
    when: squashfs.stdout.find("FAILED") != -1
    tags:
      - squashfs
      - 1.1.1.2
      - one
      - all
      
  - name: 1.1.1.2 - Ensure mounting of squashfs filesystems is disabled
    shell: "rmmod squashfs"
    failed_when: no
    when: squashfs.stdout.find("FAILED") != -1
    tags:
      - squashfs
      - 1.1.1.2
      - one
      - all

  - name:  1.1.1.3-Fetch the udf  value from ansible facts
    shell: echo "{{ ansible_local.udf_1113_audit }}" 
    register: udf
    ignore_errors: True
    tags:
      - udf
      - 1.1.1.3
      - one
      - all

  - name: 1.1.1.3 - Ensure mounting of udf filesystems is disabled
    lineinfile:
      path: /etc/modprobe.d/udf.conf
      line: "install udf /bin/true"
      state: present
      create: yes
    when: udf.stdout.find("FAILED") != -1
    tags:
      - udf
      - 1.1.1.3
      - one
      - all

  - name: 1.1.1.3 - Ensure mounting of udf filesystems is disabled
    shell: "rmmod udf"
    failed_when: no
    when: udf.stdout.find("FAILED") != -1
    tags:
      - udf
      - 1.1.1.3
      - one
      - all

  - name:  1.1.1.4-Fetch the fat  value from ansible facts
    shell: echo "{{ ansible_local.fat_1114_audit }}" 
    register: fat
    ignore_errors: True
    tags:
      - fat
      - 1.1.1.4
      - one
      - all
      
  - name: 1.1.1.4 Ensure mounting of FAT filesystems is limited
    lineinfile:
      path: /etc/modprobe.d/fat.conf
      line: "{{item}}"
      state: present
      create: yes
    with_items:
      - "install fat /bin/true"
      - "install vfat /bin/true"
      - "install msdos /bin/true"
    when: fat.stdout.find("FAILED") != -1
    tags:
      - fat
      - 1.1.1.4
      - one
      - all
      
  - name: 1.1.1.4 Ensure mounting of FAT filesystems is limited
    command: "{{item}}"
    with_items:
      - "rmmod msdos"
      - "rmmod vfat" 
      - "rmmod fat"    
    failed_when: no  
    when: fat.stdout.find("FAILED") != -1
    tags:
      - fat
      - 1.1.1.4
      - one
      - all      
      
  - name:  1.1.2-Fetch the tmp  value from ansible facts
    shell: echo "{{ ansible_local.tmp_112_audit }}" 
    register: tmp
    ignore_errors: True
    tags:
      - tmp
      - 1.1.2
      - one
      - all

  - name: 1.1.2-Ensure /tmp is configured 
    lineinfile:
      path: /etc/fstab
      line: tmpfs  /tmp  tmpfs   defaults,rw,nosuid,nodev,noexec,relatime 0 0
      state: present
#    command: "[ ! -f /etc/systemd/system/tmp.mount ] && cp -v /usr/lib/systemd/system/tmp.mount /etc/systemd/system/"
    when: tmp.stdout.find("FAILED") != -1
    tags:
      - tmp
      - 1.1.2
      - one
      - all

  - name: 1.1.2 - Ensure /tmp is configured 
    mount:
      path: /tmp
      src: /etc
      opts: noexec,nodev,nosuid
      fstype: none
      state: remounted
    failed_when: no
    when: tmp.stdout.find("FAILED") != -1
    tags:
      - tmp
      - 1.1.2
      - one
      - all 

  - name: 1.1.2 - Ensure /tmp is configured
    file: path=/etc/systemd/system/tmp.mount state=touch owner=root group=root mode=0600 
    failed_when: no    
    when: tmp.stdout.find("FAILED") != -1
    tags:
      - tmp
      - 1.1.2
      - one
      - all  
     
  - name: 1.1.2 - Ensure /tmp is configured    
    lineinfile:
      path: /etc/systemd/system/tmp.mount
      state: present
      line: "{{item}}"
    with_items:
      - "[Mount]"
      - "What=tmpfs"
      - "Where=/tmp"
      - "Type=tmpfs"
      - "Options=mode=1777,strictatime,noexec,nodev,nosuid"
    when: tmp.stdout.find("FAILED") != -1
    tags:
      - tmp
      - 1.1.2
      - one
      - all

  - name: 1.1.2 Ensure separate partition exists for /tmp
    command: "{{item}}"
    with_items:
      - "systemctl daemon-reload"
      - "systemctl unmask tmp.mount" 
#      - "systemctl enable --now tmp.mount"
    when: tmp.stdout.find("FAILED") != -1
    tags:
      - tmp
      - 1.1.2
      - one
      - all      

  - name: 1.1.2 Ensure separate partition exists for /tmp
    systemd:
      name: tmp.mount
      enabled: yes
    when: tmp.stdout.find("FAILED") != -1
    tags:
      - tmp
      - 1.1.2
      - one
      - all      

  - name:  1.1.3-Fetch the tmpnoexec  value from ansible facts 
    shell: echo "{{ ansible_local.tmpnoexec_113_audit }}" 
    register: tmpnoexec
    ignore_errors: True
    tags:
      - tmpnoexec
      - 1.1.3
      - one
      - all

  - name: 1.1.3 Ensure noexec option set on /tmp partition
    mount:
      path: /tmp
      src: /etc
      opts: noexec
      fstype: none
      state: remounted
    failed_when: no
    when: tmpnoexec.stdout.find("FAILED") != -1
    tags:
      - tmpnoexec
      - 1.1.3
      - one
      - all
      
  - name: 1.1.3 - Ensure noexec option set on /tmp partition
    command: "{{item}}"
    with_items:
      - "systemctl daemon-reload"
      - "systemctl restart tmp.mount"
    when: tmpnoexec.stdout.find("FAILED") != -1
    tags:
      - tmpnoexec
      - 1.1.3
      - one
      - all       
 
  - name:  1.1.4-Fetch the tmpnodev  value from ansible facts
    shell: echo "{{ ansible_local.tmpnodev_114_audit }}" 
    register: tmpnodev
    ignore_errors: True
    tags:
      - tmpnodev
      - 1.1.4
      - one
      - all

  - name: 1.1.4 - Ensure nodev option set on /tmp partition
    mount:
      path: /tmp
      src: /etc
      opts: nodev
      fstype: none
      state: remounted
    failed_when: no
    when: tmpnodev.stdout.find("FAILED") != -1
    tags:
      - tmpnodev
      - 1.1.4
      - one
      - all
      
  - name: 1.1.4 Ensure nodev option set on /tmp partition
    command: "{{item}}"
    with_items:
      - "systemctl daemon-reload"
      - "systemctl restart tmp.mount"
    when: tmpnodev.stdout.find("FAILED") != -1
    tags:
      - tmpnodev
      - 1.1.4
      - one
      - all      

  - name:  1.1.5-Fetch the tmpnosuid  value from ansible facts
    shell: echo "{{ ansible_local.tmpnosuid_115_audit }}" 
    register: tmpnosuid
    ignore_errors: True
    tags:
      - tmpnosuid
      - 1.1.5
      - one
      - all

  - name: 1.1.5 - Ensure nosuid option set on /tmp partition
    mount:
      path: /tmp
      src: /etc
      opts: nosuid
      fstype: none
      state: remounted
    failed_when: no
    when: tmpnosuid.stdout.find("FAILED") != -1
    tags:
      - tmpnosuid
      - 1.1.5
      - one
      - all
      
  - name: 1.1.5 - Ensure nosuid option set on /tmp partition
    command: "{{item}}"
    with_items:
      - "systemctl daemon-reload"
      - "systemctl restart tmp.mount"      
    when: tmpnosuid.stdout.find("FAILED") != -1
    tags:
      - tmpnosuid
      - 1.1.5
      - one
      - all      

  - name:  1.1.6-Fetch the shmnconfig  value from ansible facts
    shell: echo "{{ ansible_local.shmnconfig_116_audit }}"
    register: shmnconfig
    ignore_errors: True
    tags:
      - shmnconfig
      - 1.1.6
      - one
      - all

  - name: 1.1.6 - Ensure /dev/shm is configured
    lineinfile:
      path: /etc/fstab
      line: tmpfs  /dev/shm  tmpfs   defaults,noexec,nodev,nosuid,seclabel  0 0
      state: present
    when: shmnconfig.stdout.find("FAILED") != -1
    tags:
      - shmnconfig
      - 1.1.6
      - one
      - all

  - name: 1.1.6 - Ensure /dev/shm is configured
    mount:
      path: /dev/shm
      src: /etc
      opts: noexec,nodev,nosuid
      fstype: none
      state: remounted
    failed_when: no
    when: shmnconfig.stdout.find("FAILED") != -1
    tags:
      - shmnconfig
      - 1.1.6
      - one
      - all

  - name:  1.1.7-Fetch the shmnoexec  value from ansible facts 
    shell: echo "{{ ansible_local.shmnoexec_117_audit }}" 
    register: shmnoexec
    ignore_errors: True
    tags:
      - shmnoexec
      - 1.1.7
      - one
      - all
 
  - name: 1.1.7 - Ensure noexec option set on /dev/shm partition 
    mount:
      path: /dev/tmp
      src: /etc
      opts: noexec
      fstype: none
      state: remounted
    failed_when: no
    when: shmnoexec.stdout.find("FAILED") != -1
    tags:
      - shmnoexec
      - 1.1.7
      - one
      - all

  - name:  1.1.8-Fetch the shmnodev  value from ansible facts
    shell: echo "{{ ansible_local.shmnodev_118_audit }}" 
    register: shmnodev
    ignore_errors: True
    tags:
      - shmnodev
      - 1.1.8
      - one
      - all

  - name: 1.1.8 Ensure nodev option set on /dev/shm partition
    mount:
      path: /dev/tmp
      src: /etc
      opts: nodev
      fstype: none
      state: remounted
    failed_when: no
    when: shmnodev.stdout.find("FAILED") != -1
    tags:
      - shmnodev
      - 1.1.8
      - one
      - all

  - name:  1.1.9-Fetch the shmnosuid  value from ansible facts
    shell: echo "{{ ansible_local.shmnosuid_119_audit }}" 
    register: shmnosuid
    ignore_errors: True
    tags:
      - shmnosuid
      - 1.1.9
      - one
      - all
 
  - name: 1.1.9 - Ensure nosuid option set on /dev/shm partition
    mount:
      path: /dev/tmp
      src: /etc
      opts: nosuid
      fstype: none
      state: remounted
    failed_when: no
    when: shmnosuid.stdout.find("FAILED") != -1
    tags:
      - shmnosuid
      - 1.1.9
      - one
      - all

  - name:  1.1.10-Fetch the var  value from ansible facts 
    shell: echo "{{ ansible_local.var_1110_audit }}" 
    register: var
    ignore_errors: True
    tags:
      - var
      - 1.1.10
      - one
      - all

  - name: 1.1.10 - Ensure separate partition exists for /var 
    shell: (sudo grep "/var" /etc/fstab | wc -l)
    ignore_errors: yes
    register: uname_result
    when: var.stdout.find("FAILED") != -1
    tags:
      - var
      - 1.1.10
      - one
      - all

  - name: 1.1.10 - Ensure separate partition exists for /var 
    debug: msg="The partition /var is already created"
    when:
      - var.stdout.find("FAILED") != -1
      - uname_result.stdout == "0"  
    tags:
      - var
      - 1.1.10
      - one
      - all

  - name:  1.1.11-Fetch the vartmp  value from ansible facts 
    shell: echo "{{ ansible_local.vartmp_1111_audit }}" 
    register: vartmp
    ignore_errors: True
    tags:
      - vartmp
      - 1.1.11
      - one
      - all

  - name: 1.1.11 - Ensure separate partition exists for /var/tmp (Scored)
    shell: (sudo grep "/var/tmp " /etc/fstab | wc -l)
    ignore_errors: yes
    register: uname_result
    when: vartmp.stdout.find("FAILED") != -1
    tags:
      - vartmp
      - 1.1.11
      - one
      - all

  - name: 1.1.11 - Ensure separate partition exists for /var/tmp (Scored)
    debug: msg="The partition /var/tmp is already created"
    when:
      - vartmp.stdout.find("FAILED") != -1
      - uname_result.stdout == "0" 
    tags: 
      - vartmp
      - 1.1.11
      - one
      - all

  - name: 1.1.12 -Fetch the vtnoexec  value from ansible facts
    shell: echo "{{ ansible_local.vtnoexec_1112_audit }}" 
    register: vtnoexec
    ignore_errors: True
    tags:
      - vtnoexec
      - 1.1.12
      - one
      - all

  - name: 1.1.12 - Ensure noexec options set on /var/tmp partition
    mount:
      path: /var/tmp
      src: /etc
      opts: noexec
      fstype: non
      state: remounted
    failed_when: no
    when: vtnoexec.stdout.find("FAILED") != -1
    tags:
      - vtnoexec
      - 1.1.12
      - one
      - all

  - name: 1.1.13-Fetch the vtnodev  value from ansible facts
    shell: echo "{{ ansible_local.vtnodev_1113_audit }}" 
    register: vtnodev
    ignore_errors: True
    tags:
      - vtnodev
      - 1.1.13
      - one
      - all

  - name: 1.1.13 Ensure nodev options set on /var/tmp partition
    mount:
      path: /var/tmp
      src: /etc
      opts: nodev
      fstype: none
      state: remounted
    failed_when: no
    when: vtnodev.stdout.find("FAILED") != -1
    tags:
      - vtnodev
      - 1.1.13
      - one
      - all
      
  - name:  1.1.14-Fetch the vtnosuid  value from ansible facts
    shell: echo "{{ ansible_local.vtnosuid_1114_audit }}" 
    register:  vtnosuid
    ignore_errors: True
    tags:
      - vtnosuid
      - 1.1.14
      - one
      - all
    
  - name: 1.1.14 Ensure nosuid options set on /var/tmp partition
    mount:
      path: /var/tmp
      src: /etc
      opts: nosuid
      fstype: none
      state: remounted
    failed_when: no
    when: vtnosuid.stdout.find("FAILED") != -1
    tags:
      - vtnosuid
      - 1.1.14
      - one
      - all

  - name:  1.1.15-Fetch the  varlog value from ansible facts
    shell: echo "{{ ansible_local.varlog_1115_audit }}" 
    register: varlog
    ignore_errors: True
    tags:
      - varlog
      - 1.1.15
      - one
      - all

  - name: 1.1.15 - Ensure separate partition exists for /var/log  
    shell: (sudo grep "/var/log " /etc/fstab | wc -l)
    ignore_errors: yes
    register: uname_result
    when: varlog.stdout.find("FAILED") != -1
    tags:
      - varlog
      - 1.1.15
      - one
      - all

  - name: 1.1.15 - Ensure separate partition exists for /var/log
    debug: msg="The partition /var/log is already created"
    when:
      - varlog.stdout.find("FAILED") != -1
      - uname_result.stdout == "0"
    tags:
      - varlog
      - 1.1.15
      - one
      - all

  - name:  1.1.16-Fetch the varlogaudit  value from ansible facts
    shell: echo "{{ ansible_local.varlogaudit_1116_audit }}" 
    register: varlogaudit
    ignore_errors: True
    tags:
      - varlogaudit
      - 1.1.16
      - one
      - all

  - name: 1.1.16 - Ensure separate partition exists for /var/log/audit 
    shell: (sudo grep "/var/log/audit" /etc/fstab | wc -l)
    ignore_errors: yes
    register: uname_result
    when: varlogaudit.stdout.find("FAILED") != -1
    tags:
      - varlogaudit
      - 1.1.16
      - one
      - all

  - name: 1.1.16 - Ensure separate partition exists for /var/log/audit
    debug: msg="The partition /var/log/audit is already created"
    when:
      - varlogaudit.stdout.find("FAILED") != -1
      - uname_result.stdout == "0" 
    tags:
      - varlogaudit
      - 1.1.16
      - one
      - all

  - name:  1.1.17-Fetch the home  value from ansible facts
    shell: echo "{{ ansible_local.home_1117_audit }}" 
    register: home
    ignore_errors: True
    tags:
      - home
      - 1.1.17
      - one
      - all

  - name: 1.1.17 - Ensure separate partition exists for /home   
    shell: '(sudo grep "/home" /etc/fstab | wc -l)'
    ignore_errors: yes
    register: uname_result
    when: home.stdout.find("FAILED") != -1
    tags:
      - home
      - 1.1.17
      - one
      - all

  - name: 1.1.17 - Ensure separate partition exists for /home
    debug: msg="The partition /var/log/audit is already created"
    when:
      - home.stdout.find("FAILED") != -1
      - uname_result.stdout == "0"  
    tags:
      - home
      - 1.1.17
      - one
      - all

  - name:  1.1.18-Fetch the homenodev  value from ansible facts
    shell: echo "{{ ansible_local.homenodev_1118_audit }}" 
    register: homenodev
    ignore_errors: True
    tags:
      - homenodev
      - 1.1.18
      - one
      - all

  - name: 1.1.18 - Ensure nodev option set on /home partition
    mount:
      path: /home
      opts: nodev
      fstype: none
      state: remounted
    failed_when: no
    when: homenodev.stdout.find("FAILED") != -1
    tags:
      - homenodev
      - 1.1.18 
      - one
      - all

  - name:  1.1.22-Fetch the  stickybit value from ansible facts 
    shell: echo "{{ ansible_local.stickybit_1122_audit }}" 
    register: stickybit
    ignore_errors: True
    tags:
      - stickybit
      - 1.1.22
      - one
      - all

  - name: 1.1.22 - Ensure sticky bit is set on all world-writable directories
    shell: df --local -P | awk '{if (NR!=1) print $6}' | xargs -I '{}' find '{}' -xdev -type d \( -perm -0002 -a ! -perm -1000 \) 2>/dev/null | xargs -I '{}' chmod a+t '{}'
    changed_when: no
    failed_when: no
    when: stickybit.stdout.find("FAILED") != -1
    tags:
      - stickybit
      - 1.1.22
      - one
      - all  

  - name:  1.1.23-Fetch the automount  value from ansible facts
    shell: echo "{{ ansible_local.automount_1123_audit }}" 
    register: automount
    ignore_errors: True
    tags:
      - automount
      - 1.1.23
      - one
      - all
 
  - name: 1.1.23 - Disable Automounting
    systemd:
      name: autofs
      masked: yes    
    failed_when: no
    when: automount.stdout.find("FAILED") != -1
    tags:
      - automount
      - 1.1.23
      - one
      - all

  - name:  1.1.24-Fetch the  usbstorage value from ansible facts
    shell: echo "{{ ansible_local.usbstorage_1124_audit }}" 
    register: usbstorage
    ignore_errors: True
    tags:
      - usbstorage
      - 1.1.24
      - one
      - all

  - name: 1.1.24 - Disable USB Storage
    file: path=/etc/modprobe.d/usb_storage.conf state=touch owner=root group=root mode=0600 
    when: usbstorage.stdout.find("FAILED") != -1
    tags:
      - usbstorage
      - 1.1.24
      - one
      - all    
      
  - name: 1.1.24 - Disable USB Storage
    lineinfile:
      path: /etc/modprobe.d/usb_storage.conf
      line: "install usb-storage /bin/true"
      state: present
      create: yes
    when: usbstorage.stdout.find("FAILED") != -1
    tags:
      - usbstorage
      - 1.1.24
      - one
      - all
      
  - name: 1.1.24 - Disable USB Storage
    shell: "rmmod usb-storage"
    failed_when: no
    when: usbstorage.stdout.find("FAILED") != -1
    tags:
      - usbstorage
      - 1.1.24
      - one
      - all

  - name:  1.2.1-Fetch the gpgkey  value from ansible facts 
    shell: echo "{{ ansible_local.gpgkey_121_audit }}" 
    register: gpgkey
    ignore_errors: True
    tags:
      - gpgkey
      - 1.2.1
      - one
      - all

  - name: 1.2.1 - Ensure GPG keys are configured 
    command: "sudo rpm -q gpg-pubkey --qf '%{name}-%{version}-%{release} --> %{summary}\n'"
    when: gpgkey.stdout.find("FAILED") != -1
    failed_when: no
    tags:
      - 1.2.1
      - gpgkey
      - one
      - all

  - name:  1.2.2-Fetch the repoconfig  value from ansible facts
    shell: echo "{{ ansible_local.repoconfig_122_audit }}" 
    register: repoconfig
    ignore_errors: True
    tags:
     - 1.2.2
     - repoconfig
     - one
     - all

  - name: 1.2.2 - Ensure package manager repositories are configured
    shell: "yum repolist"
    failed_when: no
    when: repoconfig.stdout.find("FAILED") != -1
    tags:
     - 1.2.2
     - repoconfig
     - one
     - all

  - name:  1.2.3-Fetch the gpgcheck  value from ansible facts
    shell: echo "{{ ansible_local.gpgcheck_123_audit }}" 
    register: gpgcheck
    ignore_errors: True
    tags:
      - 1.2.3
      - gpgcheck
      - one
      - all

  - name: 1.2.3 - Ensure gpgcheck is globally activated
    replace:
      name: /etc/yum.conf
      regexp: "^gpgcheck=0"
      replace: "gpgcheck=1"
    when: gpgcheck.stdout.find("FAILED") != -1
    tags:
      - 1.2.3
      - gpgcheck
      - one
      - all

  - name:  1.3.1-Fetch the sudo  value from ansible facts
    shell: echo "{{ ansible_local.sudo_131_audit }}" 
    register: sudo
    ignore_errors: True
    tags:
      - 1.3.1
      - sudo
      - one
      - all

  - name: 1.3.1 - Ensure sudo is installed
    yum:
      name: sudo
      state: present
    failed_when: no
    when: sudo.stdout.find("FAILED") != -1
    tags:
      - 1.3.1
      - sudo
      - one
      - all

  - name:  1.3.2-Fetch the sudopty  value from ansible facts
    shell: echo "{{ ansible_local.sudopty_132_audit }}" 
    register: sudopty
    ignore_errors: True
    tags:
      - sudopty
      - 1.3.2
      - one
      - all
      
  - name: 1.3.2 - Ensure sudo commands use pty
    lineinfile:
      path: /etc/sudoers
      state: present
      line: "Defaults use_pty"
    when: sudopty.stdout.find("FAILED") != -1
    tags:
      - sudopty
      - 1.3.2
      - one
      - all

  - name:  1.3.3-Fetch the sudologfiles  value from ansible facts
    shell: echo "{{ ansible_local.sudologfiles_133_audit }}" 
    register: sudologfiles
    ignore_errors: True
    tags:
      - sudologfiles
      - 1.3.3
      - one
      - all
      
  - name: 1.3.3 - Ensure sudo log file exists
    lineinfile:
      path: /etc/sudoers
      state: present
      line: 'Defaults logfile="/var/log/sudo.log"' 
    failed_when: no
    when: sudologfiles.stdout.find("FAILED") != -1
    tags:
      - sudologfiles
      - 1.3.3
      - one
      - all

  - name:  1.4.1-Fetch the aide  value from ansible facts
    shell: echo "{{ ansible_local.aide_141_audit }}" 
    register: aide
    ignore_errors: True
    tags:
      - 1.4.1
      - aide
      - one
      - all

  - name: 1.4.1 - Ensure AIDE is installed
    yum:
      name: aide
      state: present
    failed_when: no
    when: aide.stdout.find("FAILED") != -1
    tags:
      - 1.4.1
      - aide
      - one
      - all

  - name: 1.4.1 - Ensure AIDE is installed
    command: aideinit
    failed_when: no
    when: aide.stdout.find("FAILED") != -1    
    tags:
      - 1.4.1
      - aide
      - one
      - all

  - name: "1.4.1 - Ensure AIDE is installed"
    command: mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz
    ignore_errors: True
    failed_when: no
    when: aide.stdout.find("FAILED") != -1
    tags:
      - 1.4.1
      - aide
      - one
      - all

  - name:  1.4.2-Fetch the fsintegrity  value from ansible facts 
    shell: echo "{{ ansible_local.fsintegrity_142_audit }}" 
    register: fsintegrity
    ignore_errors: True
    tags:
      - 1.4.2
      - fsintegrity
      - one
      - all

  - name: 1.4.2 - Ensure filesystem integrity is regularly checked
    cron:
      name: Run Aide integrity check weekly
      user: "root"
      minute: "0"
      hour: "5"
      day: "*"
      month: "*"
      weekday: "*"
      job: "/usr/sbin/aide --check"
    when: fsintegrity.stdout.find("FAILED") != -1
    tags:
      - 1.4.2
      - fsintegrity
      - one
      - all

  - name:  1.5.1-Fetch the bootloadpass  value from ansible facts
    shell: echo "{{ ansible_local.bootloadpass_151_audit }}" 
    register: bootloadpass
    ignore_errors: True
    tags:
      - bootloadpass
      - 1.5.1
      - one
      - all
  
  - name: "1.5.1 - Ensure bootloader password is set"
    expect:
      command: grub2-setpassword
      responses:
        Enter password: "{{ bootloader_password }}"
        Confirm password: "{{ bootloader_password }}"
    failed_when: no
    when: bootloadpass.stdout.find("FAILED") != -1
    tags:
      - 1.5.1
      - bootloadpass
      - one
      - all

  - name: "1.5.1 - Ensure bootloader password is set"
    command: grub2-mkconfig -o /boot/grub2/grub.cfg
    failed_when: no
    when: bootloadpass.stdout.find("FAILED") != -1
    tags:
      - 1.5.1
      - bootloadpass
      - one
      - all

  - name:  1.5.2-Fetch the bootloadperm  value from ansible facts
    shell: echo "{{ ansible_local.bootloadperm_152_audit }}"
    register: bootloadperm
    ignore_errors: True
    tags:
      - bootloadperm
      - 1.5.2
      - one
      - all

  - name: 1.5.2 - Ensure permission on bootloader config are configured
    file:
      path: /boot/grub2/grub.cfg
      owner: root
      group: root
      mode: '0600'
    when: bootloadperm.stdout.find("FAILED") != -1
    tags:
      - 1.5.2
      - bootloadperm
      - one
      - all

  - name: 1.5.2 - Ensure permission on bootloader config are configured
    file: path=/boot/grub2/user.cfg state=touch owner=root group=root mode=0600
#    ignore_errors: yes
    when: bootloadperm.stdout.find("FAILED") != -1
    tags:
      - 1.5.2
      - bootloadperm
      - one
      - all

  - name:  1.5.3-Fetch the singleusermode  value from ansible facts
    shell: echo "{{ ansible_local.singleusermode_153_audit }}" 
    register: singleusermode
    ignore_errors: True
    tags:
      - 1.5.3
      - singleusermode
      - one
      - all

  - name: 1.5.3 - Ensure authentication required for single user mode     
    command: sed -i '/ExecStart=-\/bin\/sh -c.*/s/ExecStart=-\/bin\/sh -c "/ExecStart=-\/bin\/sh -c "\/usr\/sbin\/sulogin; /g' /usr/lib/systemd/system/rescue.service
    when: singleusermode.stdout.find("FAILED") != -1
    tags:
      - 1.5.3
      - singleusermode
      - one
      - all

  - name:  1.6.1-Fetch the coredumps  value from ansible facts
    shell: echo "{{ ansible_local.coredumps_161_audit }}" 
    register: coredumps
    ignore_errors: True
    tags:
      - 1.6.1
      - coredumps
      - one
      - all

  - name: "1.6.1 - Ensure core dumps are restricted"
    lineinfile:
      state: present
      path: /etc/security/limits.conf
      regexp: '^#?\\*.*core'
      line: '* hard core 0'
      insertbefore: '^# End of file'
    when: coredumps.stdout.find("FAILED") != -1
    tags:
      - 1.6.1
      - coredumps
      - one
      - all

  - name: "1.6.1 - Ensure core dumps are restricted"
    lineinfile:
      state: present
      dest: /etc/sysctl.conf
      regexp: "fs.suid_dumpable*"
      line: 'fs.suid_dumpable=0'
      insertbefore: '^# End of file'      
    when: coredumps.stdout.find("FAILED") != -1
    tags:
      - 1.6.1
      - coredumps
      - one
      - all

  - name: "1.6.1 - Ensure core dumps are restricted"
    sysctl:
      name: fs.suid_dumpable
      value: 0
      state: present
      reload: yes
      sysctl_set: yes
      ignoreerrors: yes
    when: coredumps.stdout.find("FAILED") != -1
    tags:
      - 1.6.1
      - coredumps
      - one
      - all

  - name: "1.6.1 - Ensure core dumps are restricted"
    lineinfile:
      state: present
      path: /etc/systemd/coredump.conf
      regexp: "^(Storage*|#Storage*)"
      line: 'Storage=none'
    failed_when: no
    when: coredumps.stdout.find("FAILED") != -1
    tags:
      - 1.6.1
      - coredumps
      - one
      - all
      
  - name: "1.6.1 - Ensure core dumps are restricted"
    lineinfile:
      state: present
      path: /etc/systemd/coredump.conf
      regexp: "^(ProcessSizeMax*|#ProcessSizeMax*)"
      line: 'ProcessSizeMax=0'
    failed_when: no
    when: coredumps.stdout.find("FAILED") != -1
    tags:
      - 1.6.1
      - coredumps
      - one
      - all

  - name: "1.6.1 - Ensure core dumps are restricted"
    systemd:
      daemon_reload: yes
    failed_when: no
    when: coredumps.stdout.find("FAILED") != -1
    tags:
      - 1.6.1
      - coredumps
      - one
      - all

  - name:  1.6.2-Fetch the xdnx  value from ansible facts
    shell: echo "{{ ansible_local.xdnx_162_audit }}" 
    register: xdnx
    ignore_errors: True
    tags:
      - 1.6.2
      - xdnx
      - one
      - all
 
  - name: 1.6.2 - Ensure XD/NX support is enabled
    shell: (dmesg | grep NX.*active | awk -F'] ' {'print $2'} | wc -l)
    failed_when: no
    register: xdenb
    when: xdnx.stdout.find("FAILED") != -1
    tags:
      - 1.6.2
      - xdnx
      - one
      - all

  - name: 1.6.2 - Ensure XD/NX support is enabled
    debug: msg="XD/NX support is enabled"
    when: 
      - xdnx.stdout.find("FAILED") != -1
      - xdenb.stdout == "1"
    tags:
      - xdnx
      - 1.6.2
      - one
      - all
          
  - name: 1.6.2 - Ensure XD/NX support is enabled
    debug: msg="Install kernel with PAE support for 32-bit system"
    when:
      - xdnx.stdout.find("FAILED") != -1
      - xdenb.stdout == "0"
    tags:
      - xdnx
      - 1.6.2
      - one
      - all

  - name: 1.6.3-Fetch the aslr  value from ansible facts
    shell: echo "{{ ansible_local.aslr_163_audit }}" 
    register: aslr
    ignore_errors: True
    tags:
      - 1.6.3
      - aslr
      - one
      - all

  - name: 1.6.3 - Ensure address space layout randomization (ASLR) is enabled
    lineinfile:
      path: /etc/sysctl.conf
      regexp: "^(kernel.randomize_va_space*|#kernel.randomize_va_space*)"
      line: "kernel.randomize_va_space=2"
      state: present
    when: aslr.stdout.find("FAILED") != -1
    tags:
      - 1.6.3
      - aslr
      - one
      - all

  - name: 1.6.3 - Ensure address space layout randomization (ASLR) is enabled
    sysctl:
      name: kernel.randomize_va_space
      value: 2
      state: present
      reload: yes
      sysctl_set: yes
      ignoreerrors: yes
    when: aslr.stdout.find("FAILED") != -1
    tags:
      - 1.6.3
      - aslr
      - one
      - all

  - name:  1.6.4-Fetch the prelink  value from ansible facts
    shell: echo "{{ ansible_local.prelink_164_audit }}" 
    register: prelink
    ignore_errors: True
    tags:
      - 1.6.4
      - prelink
      - one
      - all

  - name: 1.6.4 - Ensure prelink is disabled
    yum:
      name: prelink
      state: absent
    failed_when: no
    when: prelink.stdout.find("FAILED") != -1
    tags:
      - 1.6.4
      - prelink
      - one
      - all

  - name:  1.7.1.1-Fetch the selinux  value from ansible facts
    shell: echo "{{ ansible_local.selinux_1711_audit }}" 
    register: selinux
    ignore_errors: True
    tags:
      - 1.7.1.1
      - selinux
      - one
      - all

  - name: 1.7.1.1 - Ensure SELinux is installed
    yum:
      name: libselinux 
      state: present
    failed_when: no
    when: selinux.stdout.find("FAILED") != -1
    tags:
      - 1.7.1.1
      - selinux
      - one
      - all

  - name:  1.7.1.2-Fetch the seldisable  value from ansible facts
    shell: echo "{{ ansible_local.seldisable_1712_audit }}" 
    register: seldisable
    ignore_errors: True
    tags:
      - 1.7.1.2
      - seldisable
      - one
      - all

  - name: 1.7.1.2 - Ensure SELinux is not disabled in bootloader configuration
    replace:
      dest: /etc/default/grub
      regexp: '(selinux|enforcing)\s*=\s*0\s*'
      follow: yes
    failed_when: no
    when: seldisable.stdout.find("FAILED") != -1
    tags:
      - 1.7.1.2
      - seldisable
      - one
      - all

  - name: 1.7.1.2 - Ensure SELinux is not disabled in bootloader configuration
    command: grub2-mkconfig -o /boot/grub2/grub.cfg
    when: seldisable.stdout.find("FAILED") != -1
    tags:
      - 1.7.1.2
      - seldisable
      - one
      - all

  - name:   1.7.1.3-Fetch the selpolicy  value from ansible facts
    shell: echo "{{ ansible_local.selpolicy_1713_audit }}" 
    register: selpolicy
    ignore_errors: True
    tags:
      - 1.7.1.3
      - selpolicy
      - one
      - all

  - name: 1.7.1.3 - Ensure SELinux policy is configured
    replace:
      path: /etc/selinux/config
      regexp: '^SELINUXTYPE=.*'
      replace: 'SELINUXTYPE=targeted'
    when: selpolicy.stdout.find("FAILED") != -1
    tags:
      - 1.7.1.3
      - selpolicy
      - one
      - all

  - name:  1.7.1.4-Fetch the selenfperm  value from ansible facts
    shell: echo "{{ ansible_local.selenfperm_1714_audit }}" 
    register: selenfperm
    ignore_errors: True
    tags:
      - 1.7.1.4
      - selenfperm
      - one
      - all

  - name: 1.7.1.4 - Ensure the SELinux mode is enforcing or permissive
    replace:
      path: /etc/selinux/config
      regexp: '^SELINUX=.*'
      replace: 'SELINUX={{ selinux }}'
    when: selenfperm.stdout.find("FAILED") != -1
    tags:
      - 1.7.1.4
      - selenfperm
      - one
      - all

  - name:  1.7.1.5-Fetch the  selstate value from ansible facts
    shell: echo "{{ ansible_local.selstate_1715_audit }}" 
    register: selstate
    ignore_errors: True
    tags:
      - 1.7.1.5
      - selstate
      - one
      - all

  - name: 1.7.1.5 - Ensure the SELinux state is enforcing
    replace:
      path: /etc/selinux/config
      regexp: '^(SELINUX=disabled|SELINUX=permissive)'
      replace: 'SELINUX=enforcing'
    when: selstate.stdout.find("FAILED") != -1
    tags:
      - 1.7.1.5
      - selstate
      - one
      - all

  - name:  1.7.1.7-Fetch the  setroubleshoot value from ansible facts
    shell: echo "{{ ansible_local.setroubleshoot_1717_audit }}" 
    register: setroubleshoot
    ignore_errors: True
    tags:
      - 1.7.1.7
      - setroubleshoot
      - one
      - all

  - name: 1.7.1.7 - Ensure SETroubleshoot is not installed 
    yum:
      name: setroubleshoot
      state: absent
    failed_when: no
    when: setroubleshoot.stdout.find("FAILED") != -1
    tags:
      - 1.7.1.7
      - setroubleshoot
      - one
      - all

  - name:  1.7.1.8-Fetch the  mcs value from ansible facts
    shell: echo "{{ ansible_local.mcs_1718_audit }}" 
    register: mcs
    ignore_errors: True
    tags:
      - 1.7.1.8
      - mcs
      - one
      - all

  - name: 1.7.1.8 - Ensure the MCS Translation Service (mcstrans) is not installed
    yum:
      name: mcstrans
      state: absent
    failed_when: no
    when: mcs.stdout.find("FAILED") != -1
    tags:
      - 1.7.1.8
      - mcs
      - one
      - all

  - name:  1.8.1.1-Fetch the  msgday value from ansible facts
    shell: echo "{{ ansible_local.msgday_1811_audit }}" 
    register: msgday
    ignore_errors: True
    tags:
      - 1.8.1.1
      - msgday
      - one
      - all

  - name: 1.8.1.1 - Ensure message of the day is configured properly
    lineinfile:
      path: /etc/motd
      state: present
      line: "Welcome to centos 7"
      create: yes
    when: msgday.stdout.find("FAILED") != -1
    tags:
      - 1.8.1.1
      - msgday
      - one
      - all

  - name:  1.8.1.2-Fetch the locallogin  value from ansible facts
    shell: echo "{{ ansible_local.locallogin_1812_audit }}" 
    register: locallogin
    ignore_errors: True
    tags:
      - locallogin
      - 1.8.1.2
      - one
      - all

  - name: 1.8.1.2 - Ensure local login warning banner is configured properly
    shell: echo "" > /etc/issue
    when: locallogin.stdout.find("FAILED") != -1
    tags:
      - 1.8.1.2
      - locallogin
      - one
      - all
      
  - name: 1.8.1.2 - Ensure local login warning banner is configured properly
    lineinfile:
      path: /etc/issue
      line: "Authorized uses only. All activity may be monitored and reported"
      state: present
    failed_when: no
    when: locallogin.stdout.find("FAILED") != -1
    tags:
      - locallogin
      - 1.8.1.2
      - one
      - all

  - name:  1.8.1.3-Fetch the remotelogin  value from ansible facts
    shell: echo "{{ ansible_local.remotelogin_1813_audit }}"
    register: remotelogin
    ignore_errors: True
    tags:
      - 1.8.1.3
      - remotelogin
      - one
      - all

  - name: 1.8.1.3 - Ensure remote login warning banner is configured properly
    shell: echo "" > /etc/issue.net
    when: remotelogin.stdout.find("FAILED") != -1
    tags:
      - 1.8.1.3
      - remotelogin
      - one
      - all
  
  - name: 1.8.1.3 - Ensure remote login warning banner is configured properly
    lineinfile:
      path: /etc/issue.net
      line: "Authorized uses only. All activity may be monitored and reported"
    when: remotelogin.stdout.find("FAILED") != -1
    tags:
      - 1.8.1.3
      - remotelogin
      - one
      - all

  - name:  1.8.1.4-Fetch the  motdperm value from ansible facts
    shell: echo "{{ ansible_local.motdperm_1814_audit }}" 
    register: motdperm
    ignore_errors: True
    tags:
      - 1.8.1.4
      - motdperm
      - one
      - all

  - name: 1.8.1.4 - Ensure permissions on /etc/motd are configured
    file:
      dest: /etc/motd
      state: file
      owner: root
      group: root
      mode: 0644
    when: motdperm.stdout.find("FAILED") != -1
    tags:
      - 1.8.1.4
      - motdperm
      - one
      - all

  - name:  1.8.1.5-Fetch the issueperm  value from ansible facts
    shell: echo "{{ ansible_local.issueperm_1815_audit }}" 
    register: issueperm
    ignore_errors: True
    tags:
      - 1.8.1.5
      - issueperm
      - one
      - all

  - name: 1.8.1.5 - Ensure permissions on /etc/issue are configured
    file:
      dest: /etc/issue
      state: file
      owner: root
      group: root
      mode: 0644
    when: issueperm.stdout.find("FAILED") != -1
    tags:
      - 1.8.1.5
      - issueperm
      - one
      - all

  - name:  1.8.1.6-Fetch the issuenetperm  value from ansible facts
    shell: echo "{{ ansible_local.issuenetperm_1816_audit }}" 
    register: issuenetperm
    ignore_errors: True
    tags:
      - 1.8.1.6
      - issuenetperm
      - one
      - all

  - name: 1.8.1.6 - Ensure permissions on /etc/issue.net are configured
    file:
      dest: /etc/issue.net
      state: file
      owner: root
      group: root
      mode: 0644
    when: issuenetperm.stdout.find("FAILED") != -1
    tags:
      - 1.8.1.6
      - issuenetperm
      - one
      - all

  - name:  1.9-Fetch the  updates value from ansible facts
    shell: echo "{{ ansible_local.updates_19_audit }}" 
    register: updates
    ignore_errors: True
    tags:
      - '1.9'
      - updates
      - one
      - all

  - name: 1.9 - Ensure updates, patches, and additional security software are installed 
    yum:
      name: "*"
      state: latest
    failed_when: no
    when: updates.stdout.find("FAILED") != -1
    tags:
      - '1.9'
      - updates
      - one
      - all

  - name:  1.10-Fetch the  gdm value from ansible facts
    shell: echo "{{ ansible_local.gdm_110_audit }}" 
    register: gdm
    ignore_errors: True
    tags:
      - '1.10'
      - gdm
      - one
      - all
 
  - name: 1.10 - Ensure GDM login banner is configured
    yum:
      name: gdm
      state: absent
    when: gdm.stdout.find("FAILED") != -1
    tags:
      - '1.10'
      - gdm
      - one
      - all

  - name: 1.10 - Ensure GDM login banner is configured
    file:
      path: /etc/dconf/profile
      state: directory
    failed_when: no
    when: gdm.stdout.find("FAILED") != -1
    tags:
      - '1.10'
      - gdm
      - one
      - all

  - name: 1.10 - Ensure GDM login banner is configured
    file:
      path: /etc/dconf/db/gdm.d/
      state: directory
    failed_when: no
    when: gdm.stdout.find("FAILED") != -1
    tags:
      - '1.10'
      - gdm
      - one
      - all

  - name: 1.10 - Ensure GDM login banner is configured
    file:
      path: /etc/dconf/profile/gdm
      state: touch
    when: gdm.stdout.find("FAILED") != -1
    tags:
      - '1.10'
      - gdm
      - one
      - all

  - name: 1.10 - Ensure GDM login banner is configured
    file:
      path: /etc/dconf/db/gdm.d/01-banner-message
      state: touch
    when: gdm.stdout.find("FAILED") != -1
    tags:
      - '1.10'
      - gdm
      - one
      - all

  - name: 1.10 - Ensure GDM login banner is configured 
    lineinfile:
      dest: "{{ item.file }}"
      regexp: "{{ item.regexp }}"
      line: "{{ item.line }}"
      state: present
      create: yes
      owner: root
      group: root
      mode: 0644
    with_items:
      - { file: '/etc/dconf/profile/gdm', regexp: 'user-db', line: 'user-db:user' }
      - { file: '/etc/dconf/profile/gdm', regexp: 'system-db', line: 'system-db:gdm' }
      - { file: '/etc/dconf/profile/gdm', regexp: 'file-db', line: 'file-db:/usr/share/gdm/greeter-dconf-defaults' }
      - { file: '/etc/dconf/db/gdm.d/01-banner-message', regexp: '\[org\/gnome\/login-screen\]', line: '[org/gnome/login-screen]' }
      - { file: '/etc/dconf/db/gdm.d/01-banner-message', regexp: 'banner-message-enable', line: 'banner-message-enable=true' }
      - { file: '/etc/dconf/db/gdm.d/01-banner-message', regexp: 'banner-message-text', line: "banner-message-text='Authorized uses only. All activity may be monitored and reported." }
    failed_when: no
    when: gdm.stdout.find("FAILED") != -1
    tags:
      - '1.10'
      - gdm
      - one
      - all

  - name: 1.10 - Ensure GDM login banner is configured
    shell: "dconf update"
    failed_when: no
    when: gdm.stdout.find("FAILED") != -1
    tags:
      - '1.10'
      - gdm
      - one
      - all

  - name:  2.1.1-Fetch the  xinetd value from ansible facts
    shell: echo "{{ ansible_local.xinetd_211_audit }}"
    register: xinetd
    ignore_errors: True
    tags:
      - xinetd
      - 2.1.1
      - two
      - all

  - name: 2.1.1 - Ensure xinetd is not installed
    yum:
      name: xinetd
      state: absent
    failed_when: no
    when: xinetd.stdout.find("FAILED") != -1
    tags:
      - xinetd
      - 2.1.1
      - two
      - all 

  - name:  2.2.1.1-Fetch the timesync  value from ansible facts
    shell: echo "{{ ansible_local.timesync_2211_audit }}"
    register: timesync
    ignore_errors: True
    tags:
      - timesync
      - 2.2.1.1
      - two
      - all

  - name: 2.2.1.1 - Ensure time synchronization is in use
    yum:
      name: "{{item}}"
      state: present
    with_items:
      - ntp
      - chrony
    failed_when: no
    when: timesync.stdout.find("FAILED") != -1
    tags:
      - timesync
      - 2.2.1.1
      - two
      - all      

  - name:  2.2.1.2-Fetch the  chrony value from ansible facts 
    shell: echo "{{ ansible_local.chrony_2212_audit }}"
    register: chrony
    ignore_errors: True
    tags:
      - chrony
      - 2.2.1.2
      - two
      - all

  - name: 2.2.1.2 - Ensure chrony is configured
    lineinfile:
      path: /etc/chrony.conf
      state: present
      line: "server <remote-server>"
    failed_when: no
    when: chrony.stdout.find("FAILED") != -1
    tags:
      - chrony
      - 2.2.1.2
      - two
      - all

  - name: 2.2.1.2 - Ensure chrony is configured
    lineinfile:
      path: /etc/sysconfig/chronyd
      state: present
      regexp: "^OPTIONS*"
      line: 'OPTIONS="-u chrony"'
    failed_when: no
    when: chrony.stdout.find("FAILED") != -1
    tags:
      - chrony
      - 2.2.1.2
      - two
      - all 

  - name:  2.2.1.3-Fetch the  ntp value from ansible facts
    shell: echo "{{ ansible_local.ntp_2213_audit }}"
    register: ntp
    ignore_errors: True
    tags:
      - ntp
      - 2.2.1.3
      - two
      - all

  - name: 2.2.1.3 - Ensure ntp is configured
    file: path=/etc/ntp.conf state=touch owner=root group=root mode=0600
    when: ntp.stdout.find("FAILED") != -1
    tags:
      - ntp
      - 2.2.1.3
      - two
      - all

  - name: 2.2.1.3 - Ensure ntp is configured
    lineinfile:
       path: /etc/ntp.conf
       state: present
       line: "{{item}}"
    with_items:
      - "restrict -4 default kod nomodify notrap nopeer noquery"
      - "restrict -6 default kod nomodify notrap nopeer noquery"
      - "server <remote-server>"
    failed_when: no
    when: ntp.stdout.find("FAILED") != -1
    tags:
      - ntp
      - 2.2.1.3
      - two
      - all


  - name: 2.2.1.3 - Ensure ntp is configured
    file: path=/etc/sysconfig/ntpd state=touch owner=root group=root mode=0600
    when: ntp.stdout.find("FAILED") != -1
    tags:
      - ntp
      - 2.2.1.3
      - two
      - all

  - name: 2.2.1.3 - Ensure ntp is configured
    lineinfile:
      path: /etc/sysconfig/ntpd
      state: present
      regexp: "^OPTIONS*"
      line: 'OPTIONS="-u ntp:ntp"'
    failed_when: no
    when: ntp.stdout.find("FAILED") != -1
    tags:
      - ntp
      - 2.2.1.3
      - two
      - all

  - name:  2.2.2-Fetch the  xorg value from ansible facts
    shell: echo "{{ ansible_local.xorg_222_audit }}"
    register: xorg
    ignore_errors: True
    tags:
      - xorg
      - 2.2.2
      - two
      - all

  - name: 2.2.2 - Ensure X11 Server components is not installed
    yum:
      name: "xorg-xll-server*"
      state: absent
    failed_when: no
    when: xorg.stdout.find("FAILED") != -1
    tags:
      - xorg
      - 2.2.2
      - two
      - all      

  - name:  2.2.3-Fetch the  avahi value from ansible facts
    shell: echo "{{ ansible_local.avahi_223_audit }}"
    register: avahi
    ignore_errors: True
    tags:
      - avahi
      - 2.2.3
      - two
      - all

  - name: 2.2.3 - Ensure Avahi Server is not enabled
    service:
      name: avahi-daemon.socket
      state: stopped
    failed_when: no
    when: avahi.stdout.find("FAILED") != -1 
    tags:
      - avahi
      - 2.2.3
      - two
      - all

  - name: 2.2.3 - Ensure Avahi Server is not enabled
    service:
      name: avahi-daemon.service
      state: stopped
    failed_when: no
    when: avahi.stdout.find("FAILED") != -1 
    tags:
      - avahi
      - 2.2.3
      - two
      - all

  - name: 2.2.3 - Ensure Avahi Server is not installed
    yum:
      name: avahi-autoipd avahi
      state: absent
    failed_when: no
    when: avahi.stdout.find("FAILED") != -1 
    tags:
      - avahi
      - 2.2.3
      - two
      - all

  - name: 2.2.3 - Ensure Avahi Server is not installed
    yum:
      name: avahi
      state: absent
    failed_when: no
    when: avahi.stdout.find("FAILED") != -1 
    tags:
      - avahi
      - 2.2.3
      - two
      - all

  - name:  2.2.4-Fetch the cups  value from ansible facts
    shell: echo "{{ ansible_local.cups_224_audit }}"
    register: cups
    ignore_errors: True
    tags:
      - cups
      - 2.2.4
      - two
      - all

  - name: 2.2.4 - Ensure CUPS is not installed
    yum:
      name: cups
      state: absent
    failed_when: no
    when: cups.stdout.find("FAILED") != -1
    tags:
      - two
      - cups
      - 2.2.4
      - all

  - name:  2.2.5-Fetch the  dhcp value from ansible facts
    shell: echo "{{ ansible_local.dhcp_225_audit }}"
    register: dhcp
    ignore_errors: True
    tags:
      - dhcp
      - 2.2.5
      - two
      - all

  - name: 2.2.5 - Ensure DHCP Server is not installed
    yum:
      name: dhcpd
      state: absent
    failed_when: no
    when: dhcp.stdout.find("FAILED") != -1
    tags:
      - two
      - dhcp
      - 2.2.5
      - all

  - name:  2.2.6-Fetch the ldap  value from ansible facts
    shell: echo "{{ ansible_local.ldap_226_audit }}"
    register: ldap
    ignore_errors: True
    tags:
      - ldap
      - 2.2.6
      - two
      - all

  - name: 2.2.6 - Ensure LDAP server is not installed
    yum:
      name: openldap-servers
      state: absent
    failed_when: no
    when: ldap.stdout.find("FAILED") != -1
    tags:
      - two
      - ldap
      - 2.2.6
      - all      

  - name: 2.2.7 -Fetch the  nfs value from ansible facts
    shell: echo "{{ ansible_local.nfs_227_audit }}"
    register: nfs
    ignore_errors: True
    tags:
      - nfs
      - 2.2.7
      - two
      - all

  - name: 2.2.7 - Ensure nfs-utils is not installed or the nfs-server service is masked
    yum:
      name: nfs-utils
      state: absent
    failed_when: no
    when: nfs.stdout.find("FAILED") != -1
    tags:
      - nfs
      - 2.2.7
      - two
      - all

  - name: 2.2.7 - Ensure nfs-utils is not installed or the nfs-server service is masked
    service:
      name: nfs-server
      masked: yes
    failed_when: no
    when: nfs.stdout.find("FAILED") != -1
    tags:
      - nfs
      - 2.2.7
      - two
      - all

  - name:  2.2.8-Fetch the rpcbind  value from ansible facts     
    shell: echo "{{ ansible_local.rpcbind_228_audit }}"
    register: rpcbind
    ignore_errors: True
    tags:
      - rpcbind
      - 2.2.8
      - two
      - all

  - name: 2.2.8 - Ensure rpcbind is not installed or the rpcbind services are masked      
    yum:
      name: rpcbind
      state: absent
    failed_when: no
    when: rpcbind.stdout.find("FAILED") != -1
    tags:
      - rpcbind
      - 2.2.8
      - two
      - all

#  - name: 2.2.8 - Ensure rpcbind is not installed or the rpcbind services are masked      
#    service:
#      name: rpcbind
#      masked: yes
#    failed_when: no
#    when: rpcbind.stdout.find("FAILED") != -1
#    tags:
#      - rpcbind
#      - 2.2.8
#      - two
#      - all

#  - name: 2.2.8 - Ensure rpcbind is not installed or the rpcbind services are masked      
#    service:
#      name: rpcbind.socket
#      masked: yes
#    failed_when: no
#    when: rpcbind.stdout.find("FAILED") != -1
#    tags:
#      - rpcbind
#      - 2.2.8
#      - two
#      - all

  - name:  2.2.9-Fetch the  dns value from ansible facts
    shell: echo "{{ ansible_local.dns_229_audit }}"
    register: dns
    ignore_errors: True
    tags:
      - dns
      - 2.2.9
      - two
      - all

  - name: 2.2.9 - Ensure DNS Server is not installed
    yum:
      name: bind
      state: absent
    failed_when: no
    when: dns.stdout.find("FAILED") != -1
    tags:
      - dns
      - 2.2.9
      - two
      - all

  - name:  2.2.10-Fetch the ftp  value from ansible facts
    shell: echo "{{ ansible_local.ftp_2210_audit }}"
    register: ftp
    ignore_errors: True
    tags:
      - ftp
      - 2.2.10
      - two
      - all

  - name: 2.2.10 - Ensure FTP Server is not installed
    yum:
      name: vsftpd
      state: absent
    failed_when: no
    when: ftp.stdout.find("FAILED") != -1
    tags:
      - ftp
      - 2.2.10
      - two
      - all      

  - name:  2.2.11-Fetch the http  value from ansible facts
    shell: echo "{{ ansible_local.http_2211_audit }}"
    register: http
    ignore_errors: True
    tags:
      - http
      - 2.2.11
      - two
      - all

  - name: 2.2.11 - Ensure HTTP server is not installed
    yum:
      name: httpd
      state: absent
    failed_when: no
    when: http.stdout.find("FAILED") != -1
    tags:
      - http
      - 2.2.11
      - two
      - all

  - name: 2.2.12-Fetch the imap  value from ansible facts
    shell: echo "{{ ansible_local.imap_2212_audit }}"
    register: imap
    ignore_errors: True
    tags:
      - imap
      - 2.2.12
      - two
      - all 

  - name: 2.2.12 - Ensure IMAP and POP3 server is not installed
    yum:
      name: dovecot
      state: absent
    failed_when: no
    when: imap.stdout.find("FAILED") != -1
    tags:
      - imap
      - 2.2.12
      - two
      - all

  - name:  2.2.13-Fetch the samba  value from ansible facts
    shell: echo "{{ ansible_local.samba_2213_audit }}"
    register: samba
    ignore_errors: True
    tags:
      - samba
      - 2.2.13
      - two
      - all

  - name: 2.2.13 - Ensure Samba is not installed
    yum:
      name: samba
      state: absent
    failed_when: no
    when: samba.stdout.find("FAILED") != -1
    tags:
      - samba
      - 2.2.13
      - two
      - all

  - name:  2.2.14-Fetch the proxy  value from ansible facts 
    shell: echo "{{ ansible_local.proxy_2214_audit }}"
    register: proxy
    ignore_errors: True
    tags:
      - proxy
      - 2.2.14
      - two
      - all

  - name: 2.2.14 - Ensure HTTP Proxy Server is not installed
    yum:
      name: squid
      state: absent
    failed_when: no
    when: proxy.stdout.find("FAILED") != -1
    tags:
      - proxy
      - 2.2.14
      - two
      - all

  - name:  2.2.15-Fetch the snmp  value from ansible facts
    shell: echo "{{ ansible_local.snmp_2215_audit }}"
    register: snmp
    ignore_errors: True
    tags:
      - snmp
      - 2.2.15
      - two
      - all

  - name: 2.2.15 - Ensure net-snmp is not installed
    yum:
      name: net-snmp
      state: absent
    failed_when: no
    when: snmp.stdout.find("FAILED") != -1
    tags:
      - snmp
      - 2.2.15
      - two
      - all

  - name:  2.2.16-Fetch the mail  value from ansible facts
    shell: echo "{{ ansible_local.mail_2216_audit }}"
    register: mail
    ignore_errors: True
    tags:
      - mail
      - 2.2.16
      - two
      - all

  - name: 2.2.16 - Ensure mail transfer agent is configured for local-only mode
    yum: 
      name: postfix 
      state: present
    failed_when: no
    when: mail.stdout.find("FAILED") != -1
    tags:
      - mail
      - 2.2.16
      - two
      - all

  - name: 2.2.16 - Ensure mail transfer agent is configured for local-only mode
    lineinfile:
      path: /etc/postfix/main.cf
      state: present
      regexp: "^inet_interfaces*"
      line: "inet_interfaces = loopback-only"
    failed_when: no
    when: mail.stdout.find("FAILED") != -1
    tags:
      - mail
      - 2.2.16
      - two
      - all

  - name: 2.2.16 - Ensure mail transfer agent is configured for local-only mode
    service:
      name: postfix
      state: restarted
    failed_when: no
    when: mail.stdout.find("FAILED") != -1
    tags:
      - mail
      - 2.2.16
      - two
      - all

  - name:  2.2.17-Fetch the  rsync value from ansible facts 
    shell: echo "{{ ansible_local.rsync_2217_audit }}"
    register: rsync
    ignore_errors: True
    tags:
      - rsync
      - 2.2.17
      - two
      - all

  - name: 2.2.17 - Ensure rsync is not installed or the rsyncd service is masked 
    yum:
      name: rsync
      state: absent
    failed_when: no
    when: rsync.stdout.find("FAILED") != -1
    tags:
      - rsync
      - 2.2.17
      - two
      - all

#  - name: 2.2.17 - Ensure rsync is not installed or the rsyncd service is masked 
#    service:
#      name: rsyncd
#      masked: yes
#    failed_when: no
#    when: rsync.stdout.find("FAILED") != -1
#    tags:
#      - rsync
#      - 2.2.17
#      - two
#      - all

  - name:  2.2.18-Fetch the nis  value from ansible facts
    shell: echo "{{ ansible_local.nis_2218_audit }}"
    register: nis
    ignore_errors: True
    tags:
      - nis
      - 2.2.18
      - two
      - all

  - name: 2.2.18 - Ensure NIS Server is not installed
    yum:
      name: ypserv
      state: absent
    failed_when: no
    when: nis.stdout.find("FAILED") != -1
    tags:
      - nis
      - 2.2.18
      - two
      - all

  - name:  2.2.19-Fetch the telnet  value from ansible facts
    shell: echo "{{ ansible_local.telnet_2219_audit }}"
    register: telnet
    ignore_errors: True
    tags:
      - telnet
      - 2.2.19
      - two
      - all

  - name: 2.2.19 - Ensure telnet-server is not installed
    yum:
      name: telnet-server
      state: absent
    failed_when: no
    when: telnet.stdout.find("FAILED") != -1
    tags:
      - telnet
      - 2.2.19
      - two
      - all     

  - name:  2.3.1-Fetch the nisc  value from ansible facts
    shell: echo "{{ ansible_local.nisc_231_audit }}"
    register: nisc
    ignore_errors: True
    tags:
      - nisc
      - 2.3.1
      - two
      - all

  - name: 2.3.1 - Ensure NIS Client is not installed
    yum:
      name: ypbind
      state: absent
    failed_when: no
    when: nisc.stdout.find("FAILED") != -1
    tags:
      - nisc
      - 2.3.1
      - two
      - all

  - name:  2.3.2-Fetch the rshc  value from ansible facts
    shell: echo "{{ ansible_local.rshc_232_audit }}"
    register: rshc
    ignore_errors: True
    tags:
      - rshc
      - 2.3.2
      - two
      - all

  - name: 2.3.2 - Ensure RSH Client is not installed
    yum:
      name: rsh
      state: absent
    failed_when: no
    when: rshc.stdout.find("FAILED") != -1
    tags:
      - rshc
      - 2.3.2
      - two
      - all

  - name:  2.3.3-Fetch the  talkc value from ansible facts
    shell: echo "{{ ansible_local.talkc_233_audit }}"
    register: talkc
    ignore_errors: True
    tags:
      - talkc
      - 2.3.3
      - two
      - all

  - name: 2.3.3 - Ensure talk client is not installed
    yum:
      name: talk
      state: absent
    failed_when: no
    when: talkc.stdout.find("FAILED") != -1
    tags:
      - talkc
      - 2.3.3
      - two
      - all

  - name:  2.3.4-Fetch the telnetc  value from ansible facts
    shell: echo "{{ ansible_local.telnetc_234_audit }}"
    register: telnetc
    ignore_errors: True
    tags:
      - telnetc
      - 2.3.4
      - two
      - all

  - name: 2.3.4 - Ensure telnet client is not installed
    yum:
      name: telnet
      state: absent
    failed_when: no
    when: telnetc.stdout.find("FAILED") != -1
    tags:
      - telnetc
      - 2.3.4
      - two
      - all

  - name:  2.3.5-Fetch the  ldapc value from ansible facts
    shell: echo "{{ ansible_local.ldapc_235_audit }}"
    register: ldapc
    ignore_errors: True
    tags:
      - ldapc
      - 2.3.5
      - two
      - all

  - name: 2.3.5 - Ensure LDAP client is not installed
    yum:
      name: openldap-clients
      state: absent
    failed_when: no
    when: ldapc.stdout.find("FAILED") != -1
    tags:
      - ldapc
      - 2.3.5
      - two
      - all

  - name:  2.4-Fetch the nonessenserv  value from ansible facts
    shell: echo "{{ ansible_local.nonessenserv_24_audit }}"
    register: nonessenserv
    ignore_errors: True
    tags:
      - nonessenserv
      - '2.4'
      - two
      - all

  - name: 2.4 - Ensure nonessential services are removed or masked
    yum:
      name:  
      state: absent
    failed_when: no
    when: nonessenserv.stdout.find("FAILED") != -1
    tags:
      - nonessenserv
      - '2.4'
      - two
      - all

#  - name: 2.4 - Ensure nonessential services are removed or masked
#    systemd:
#      name: 
#      masked: yes
#    failed_when: no
#    when: nonessenserv.stdout.find("FAILED") != -1
#    tags:
#      - nonessenserv
#      - 2.4
#      - two
#      - all

  - name:  3.1.1-Fetch the  ipv6disable value from ansible facts
    shell: echo "{{ ansible_local.ipv6disable_311_audit }}"
    register: ipv6disable
    ignore_errors: True
    tags:
      - ipv6disable
      - 3.1.1
      - three
      - all
      
  - name: 3.1.1 - Disable IPv6
    command: sed -i 's/GRUB_CMDLINE_LINUX="[^"]*/& ipv6.disable=1/' /etc/default/grub
    failed_when: no
    when: ipv6disable.stdout.find("FAILED") != -1
    tags:
      - ipv6disable
      - 3.1.1
      - three
      - all
      
  - name: 3.1.1 - Disable IPv6
    command: grub2-mkconfig o /boot/grub2/grub.cfg
    failed_when: no
    when: ipv6disable.stdout.find("FAILED") != -1
    tags:
      - ipv6disable
      - 3.1.1
      - three
      - all

  - name:  3.1.2-Fetch the wireless  value from ansible facts
    shell: echo "{{ ansible_local.wireless_312_audit }}"
    register: wireless
    ignore_errors: True
    tags:
      - wireless
      - 3.1.2
      - three
      - all

  - name: 3.1.2 - Ensure wireless interfaces are disabled
    yum: 
      name: wireless-tools 
      state: present
    failed_when: no
    when: wireless.stdout.find("FAILED") != -1
    tags:
      - wireless
      - 3.1.2
      - three
      - all

  - name: 3.1.2 - Ensure wireless interfaces are disabled
    shell: "iwconfig 2> /dev/null | grep 'no wireless' | wc -l"
    register: iwconfig
    when: wireless.stdout.find("FAILED") != -1
    tags:
      - wireless
      - 3.1.2
      - three
      - all

  - name: 3.1.2 - Ensure wireless interfaces are disabled
    shell: "ip link show up | cut -d: -f2 | grep '[aAa-zZz][0-9]' | cut -d' ' -f2 | wc -l"
    register: iplink
    when:
      - wireless.stdout.find("FAILED") != -1
      - iwconfig|int == 0
    tags:
      - wireless
      - 3.1.2
      - three
      - all

  - name: 3.1.2 - Ensure wireless interfaces are disabled
    shell: "wifi=$(ip link show up | cut -d: -f2 | grep '[aAa-zZz][0-9]' | cut -d' ' -f2) && sudo ip link set $wifi down"
    when:
      - wireless.stdout.find("FAILED") != -1
      - iplink|int >= 2
    tags:
      - wireless
      - 3.1.2
      - three
      - all

  - name:  3.2.1-Fetch the  ipforward value from ansible facts
    shell: echo "{{ ansible_local.ipforward_321_audit }}"
    register: ipforward
    ignore_errors: True
    tags:
      - ipforward
      - 3.2.1
      - three
      - all
      
  - name: 3.2.1 - Ensure IP forwarding is disabled
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv4.ip_forward*|#net.ipv4.ip_forward*)"
      line: "net.ipv4.ip_forward=0"
    failed_when: no
    when: ipforward.stdout.find("FAILED") != -1
    tags:
      - ipforward
      - 3.2.1
      - three
      - all

  - name: 3.2.1 - Ensure IP forwarding is disabled
    sysctl: "{{item}}"
    with_items:
      - name: net.ipv4.ip_forward
        value: '0'
        sysctl_set: yes
      - name: net.ipv4.route.flush
        value: '1'
        sysctl_set: yes
    failed_when: no
    when: ipforward.stdout.find("FAILED") != -1
    tags:
      - ipforward
      - 3.2.1
      - three
      - all      

  - name:  3.2.2-Fetch the packetredirect  value from ansible facts
    shell: echo "{{ ansible_local.packetredirect_322_audit }}"
    register: packetredirect
    ignore_errors: True
    tags:
      - packetredirect
      - 3.2.2
      - three
      - all

  - name: 3.2.2 - Ensure packet redirect sending is disabled
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv4.conf.all.send_redirects*|#net.ipv4.conf.all.send_redirects*)"
      line: "net.ipv4.conf.all.send_redirects=0"
    failed_when: no
    when: packetredirect.stdout.find("FAILED") != -1
    tags:
      - packetredirect
      - 3.2.2
      - three
      - all

  - name: 3.2.2 - Ensure packet redirect sending is disabled
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv4.conf.default.send_redirects*|#net.ipv4.conf.default.send_redirects*)"
      line: "net.ipv4.conf.default.send_redirects=0"
    failed_when: no
    when: packetredirect.stdout.find("FAILED") != -1
    tags:
      - packetredirect
      - 3.2.2
      - three
      - all

  - name: 3.2.2 - Ensure packet redirect sending is disabled
    sysctl: "{{item}}"
    with_items:
      - name: net.ipv4.conf.all.send_redirects
        value: '0'
        sysctl_set: yes
      - name: net.ipv4.conf.default.send_redirects 
        value: '0'
        sysctl_set: yes
      - name: net.ipv4.route.flush
        value: '1'
        sysctl_set: yes
    failed_when: no
    when: packetredirect.stdout.find("FAILED") != -1
    tags:
      - packetredirect
      - 3.2.2
      - three
      - all      

  - name:  3.3.1-Fetch the routedpacket  value from ansible facts
    shell: echo "{{ ansible_local.routedpacket_331_audit }}"
    register: routedpacket
    ignore_errors: True
    tags:
      - routedpacket
      - 3.3.1
      - three
      - all
      
  - name: 3.3.1 - Ensure source routed packets are not accepted
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv4.conf.all.accept_source_route*|#net.ipv4.conf.all.accept_source_route*)"
      line: "net.ipv4.conf.all.accept_source_route=0"
    failed_when: no
    when: routedpacket.stdout.find("FAILED") != -1
    tags:
      - routedpacket
      - 3.3.1
      - three
      - all

  - name: 3.3.1 - Ensure source routed packets are not accepted
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv4.conf.default.accept_source_route*|#net.ipv4.conf.default.accept_source_route*)"
      line: "net.ipv4.conf.default.accept_source_route=0"
    failed_when: no
    when: routedpacket.stdout.find("FAILED") != -1
    tags:
      - routedpacket
      - 3.3.1
      - three
      - all

  - name: 3.3.1 - Ensure source routed packets are not accepted
    sysctl: "{{item}}"
    with_items:
      - name: net.ipv4.conf.all.accept_source_route 
        value: '0'
        sysctl_set: yes
      - name: net.ipv4.conf.default.accept_source_route
        value: '0'
        sysctl_set: yes
      - name: net.ipv4.route.flush
        value: '1'
        sysctl_set: yes
    failed_when: no
    when: routedpacket.stdout.find("FAILED") != -1
    tags:
      - routedpacket
      - 3.3.1
      - three
      - all

  - name:  3.3.2-Fetch the  icmp value from ansible facts
    shell: echo "{{ ansible_local.icmp_332_audit }}"
    register: icmp
    ignore_errors: True
    tags:
      - icmp
      - 3.3.2
      - three
      - all
      
  - name: 3.3.2 - Ensure ICMP redirects are not accepted
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv4.conf.all.accept_redirects*|#net.ipv4.conf.all.accept_redirects*)"
      line: "net.ipv4.conf.all.accept_redirects=0"
    failed_when: no
    when: icmp.stdout.find("FAILED") != -1
    tags:
      - icmp
      - 3.3.2
      - three
      - all

  - name: 3.3.2 - Ensure ICMP redirects are not accepted
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv4.conf.default.accept_redirects*|#net.ipv4.conf.default.accept_redirects*)"
      line: "net.ipv4.conf.default.accept_redirects=0"
    failed_when: no
    when: icmp.stdout.find("FAILED") != -1
    tags:
      - icmp
      - 3.3.2
      - three
      - all

  - name: 3.3.2 - Ensure ICMP redirects are not accepted
    sysctl: "{{item}}"
    with_items:
      - name: net.ipv4.conf.all.accept_redirects
        value: '0'
        sysctl_set: yes
      - name: net.ipv4.conf.default.accept_redirects
        value: '0'
        sysctl_set: yes
      - name: net.ipv4.route.flush
        value: '1'
        sysctl_set: yes
    failed_when: no
    when: icmp.stdout.find("FAILED") != -1
    tags:
      - icmp
      - 3.3.2
      - three
      - all

  - name:  3.3.3-Fetch the secureicmp  value from ansible facts
    shell: echo "{{ ansible_local.secureicmp_333_audit }}"
    register: secureicmp
    ignore_errors: True
    tags:
      - secureicmp
      - 3.3.3
      - three
      - all
   
  - name: 3.3.3 - Ensure secure ICMP redirects are not accepted
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv4.conf.all.secure_redirects*|#net.ipv4.conf.all.secure_redirects*)"
      line: "net.ipv4.conf.default.secure_redirects=0"
    failed_when: no
    when: secureicmp.stdout.find("FAILED") != -1
    tags:
      - secureicmp
      - 3.3.3
      - three
      - all

  - name: 3.3.3 - Ensure secure ICMP redirects are not accepted
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv4.conf.default.secure_redirects*|#net.ipv4.conf.default.secure_redirects*)"
      line: "net.ipv4.conf.default.secure_redirects=0"
    failed_when: no
    when: secureicmp.stdout.find("FAILED") != -1
    tags:
      - secureicmp
      - 3.3.3
      - three
      - all

  - name: 3.3.3 - Ensure secure ICMP redirects are not accepted
    sysctl: "{{item}}"
    with_items:
      - name: net.ipv4.conf.all.secure_redirects 
        value: '0'
        sysctl_set: yes
      - name: net.ipv4.conf.default.secure_redirects
        value: '0'
        sysctl_set: yes
      - name: net.ipv4.route.flush
        value: '1'
        sysctl_set: yes
    failed_when: no
    when: secureicmp.stdout.find("FAILED") != -1
    tags:
      - secureicmp
      - 3.3.3
      - three
      - all      

  - name:  3.3.4-Fetch the suspicious  value from ansible facts
    shell: echo "{{ ansible_local.suspicious_334_audit }}"
    register: suspicious
    ignore_errors: True
    tags:
      - suspicious
      - 3.3.4
      - three
      - all   

  - name: 3.3.4 - Ensure suspicious packets are logged
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv4.conf.all.log_martians*|#net.ipv4.conf.all.log_martians*)"
      line: "net.ipv4.conf.all.log_martians=1"
    failed_when: no
    when: suspicious.stdout.find("FAILED") != -1
    tags:
      - suspicious
      - 3.3.4
      - three
      - all

  - name: 3.3.4 - Ensure suspicious packets are logged
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv4.conf.default.log_martians*|#net.ipv4.conf.default.log_martians*)"
      line: "net.ipv4.conf.default.log_martians=1"
    failed_when: no
    when: suspicious.stdout.find("FAILED") != -1
    tags:
      - suspicious
      - 3.3.4
      - three
      - all

  - name: 3.3.4 - Ensure suspicious packets are logged
    sysctl: "{{item}}"
    with_items:
      - name: net.ipv4.conf.all.log_martians 
        value: '1'
        sysctl_set: yes
      - name: net.ipv4.conf.default.log_martians
        value: '1'
        sysctl_set: yes
      - name: net.ipv4.route.flush
        value: '1'
        sysctl_set: yes
    failed_when: no
    when: suspicious.stdout.find("FAILED") != -1
    tags:
      - suspicious
      - 3.3.4
      - three
      - all      

  - name:  3.3.5-Fetch the broadcasticmp  value from ansible facts
    shell: echo "{{ ansible_local.broadcasticmp_335_audit }}"
    register: broadcasticmp
    ignore_errors: True
    tags:
      - broadcasticmp
      - 3.3.5
      - three
      - all   

  - name: 3.3.5 - Ensure broadcast ICMP requests are ignored
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv4.icmp_echo_ignore_broadcasts*|#net.ipv4.icmp_echo_ignore_broadcasts*)"
      line: "net.ipv4.icmp_echo_ignore_broadcasts=1"
    failed_when: no
    when: broadcasticmp.stdout.find("FAILED") != -1
    tags:
      - broadcasticmp
      - 3.3.5
      - three
      - all

  - name: 3.3.5 - Ensure broadcast ICMP requests are ignored
    sysctl: "{{item}}"
    with_items:
      - name: net.ipv4.icmp_echo_ignore_broadcasts
        value: '1'
        sysctl_set: yes
      - name: net.ipv4.route.flush
        value: '1'
        sysctl_set: yes
    failed_when: no
    when: broadcasticmp.stdout.find("FAILED") != -1
    tags:
      - broadcasticmp
      - 3.3.5
      - three
      - all

  - name:  3.3.6-Fetch the bogusicmp  value from ansible facts
    shell: echo "{{ ansible_local.bogusicmp_336_audit }}"
    register: bogusicmp
    ignore_errors: True
    tags:
      - bogusicmp
      - 3.3.6
      - three
      - all
      
  - name: 3.3.6 - Ensure bogus ICMP responses are ignored
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv4.icmp_ignore_bogus_error_responses*|#net.ipv4.icmp_ignore_bogus_error_responses*)"
      line: "net.ipv4.icmp_ignore_bogus_error_responses=1"
    when: bogusicmp.stdout.find("FAILED") != -1
    tags:
      - bogusicmp
      - 3.3.6
      - three
      - all

  - name: 3.3.6 - Ensure bogus ICMP responses are ignored 
    sysctl: "{{item}}"
    ignore_errors: yes
    with_items: 
      - name: net.ipv4.icmp_ignore_bogus_error_responses 
        value: '1'
        sysctl_set: yes
      - name: net.ipv4.route.flush
        value: '1'
        sysctl_set: yes 
    failed_when: no
    when: bogusicmp.stdout.find("FAILED") != -1
    tags:
      - bogusicmp
      - 3.3.6
      - three
      - all      

  - name:  3.3.7-Fetch the  reversepathfilter value from ansible facts
    shell: echo "{{ ansible_local.reversepathfilter_337_audit }}"
    register: reversepathfilter
    ignore_errors: True
    tags:
      - reversepathfilter
      - 3.3.7
      - three
      - all
      
  - name: 3.3.7 - Ensure Reverse Path Filtering is enabled
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "{{item.regexp}}"
      line: "{{item.line}}"
    with_items:
      - {regexp: "^(net.ipv4.conf.all.rp_filter*|#net.ipv4.conf.all.rp_filter*)" ,line: "net.ipv4.conf.all.rp_filter=1"}
      - {regexp: "^(net.ipv4.conf.default.rp_filter*|#net.ipv4.conf.default.rp_filter*)" ,line: "net.ipv4.conf.default.rp_filter=1"}
    failed_when: no
    when: reversepathfilter.stdout.find("FAILED") != -1
    tags:
      - reversepathfilter
      - 3.3.7
      - three
      - all

  - name: 3.3.7 - Ensure Reverse Path Filtering is enabled
    sysctl: "{{item}}"
    ignore_errors: yes
    with_items:
      - name: net.ipv4.conf.all.rp_filter
        value: '1'
        sysctl_set: yes
      - name: net.ipv4.conf.default.rp_filter
        value: '1'
        sysctl_set: yes
      - name: net.ipv4.route.flush
        value: '1'
        sysctl_set: yes
    become: yes
    failed_when: no
    when: reversepathfilter.stdout.find("FAILED") != -1
    tags:
      - reversepathfilter
      - 3.3.7
      - three
      - all       

  - name:  3.3.8-Fetch the tcpsyncookies  value from ansible facts 
    shell: echo "{{ ansible_local.tcpsyncookies_338_audit }}"
    register: tcpsyncookies
    ignore_errors: True
    tags:
      - tcpsyncookies
      - 3.3.8
      - three
      - all   

  - name: 3.3.8 - Ensure TCP SYN Cookies is enabled
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv4.tcp_syncookies*|#net.ipv4.tcp_syncookies*)"
      line: "net.ipv4.tcp_syncookies=1"
    when: tcpsyncookies.stdout.find("FAILED") != -1
    tags:
      - tcpsyncookies
      - 3.3.8
      - three
      - all

  - name: 3.3.8 - Ensure TCP SYN Cookies is enabled 
    sysctl: "{{item}}"
    ignore_errors: yes
    with_items:
      - name: net.ipv4.tcp_syncookies
        value: '1'
        sysctl_set: yes
      - name: net.ipv4.route.flush
        value: '1'
        sysctl_set: yes
    failed_when: no
    when: tcpsyncookies.stdout.find("FAILED") != -1
    tags:
      - tcpsyncookies
      - 3.3.8
      - three
      - all

  - name:  3.3.9-Fetch the ipv6router  value from ansible facts
    shell: echo "{{ ansible_local.ipv6router_339_audit }}"
    register: ipv6router
    ignore_errors: True
    tags:
      - ipv6router
      - 3.3.9
      - three
      - all   

  - name: 3.3.9 - Ensure IPv6 router advertisements are not accepted
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv6.conf.all.accept_ra*|#net.ipv6.conf.all.accept_ra*)"
      line: "net.ipv6.conf.all.accept_ra=0"
    failed_when: no
    when: ipv6router.stdout.find("FAILED") != -1
    tags:
      - ipv6router
      - 3.3.9
      - three
      - all

  - name: 3.3.9 - Ensure IPv6 router advertisements are not accepted
    lineinfile:
      path: /etc/sysctl.conf
      state: present
      regexp: "^(net.ipv6.conf.default.accept_ra*|#net.ipv6.conf.default.accept_ra*)"
      line: "net.ipv6.conf.default.accept_ra=0"
    failed_when: no
    when: ipv6router.stdout.find("FAILED") != -1
    tags:
      - ipv6router
      - 3.3.9
      - three
      - all

  - name: 3.3.9 - Ensure IPv6 router advertisements are not accepted
    sysctl: "{{item}}"
    with_items:
      - name: net.ipv6.conf.all.accept_ra 
        value: '0'
        sysctl_set: yes    
      - name: net.ipv6.conf.default.accept_ra
        value: '0'
        sysctl_set: yes
      - name: net.ipv6.route.flush
        value: '1'
        sysctl_set: yes
    failed_when: no
    when: ipv6router.stdout.find("FAILED") != -1
    tags:
      - ipv6router
      - 3.3.9
      - three
      - all      

  - name:  3.4.1-Fetch the dccp  value from ansible facts
    shell: echo "{{ ansible_local.dccp_341_audit }}"
    register: dccp
    ignore_errors: True
    tags:
      - dccp
      - 3.4.1
      - three
      - all      
  
  - name: 3.4.1 - Ensure DCCP is disabled
    lineinfile:
      path: /etc/modprobe.d/dccp.conf
      state: present
      line: "install dccp /bin/true"
      create: yes
    failed_when: no
    when: dccp.stdout.find("FAILED") != -1
    tags:
      - dccp
      - 3.4.1
      - three
      - all 

  - name:  3.4.2-Fetch the  sctp value from ansible facts
    shell: echo "{{ ansible_local.sctp_342_audit }}"
    register: sctp
    ignore_errors: True
    tags:
      - sctp
      - 3.4.2
      - three
      - all   

  - name: 3.4.2 - Ensure SCTP is disabled
    lineinfile:
      path: /etc/modprobe.d/sctp.conf
      state: present
      line: "install sctp /bin/true"
      create: yes
    failed_when: no
    when: sctp.stdout.find("FAILED") != -1
    tags:
      - sctp
      - 3.4.2
      - three
      - all

  - name:  3.5.1.1-Fetch the firewallpack  value from ansible facts
    shell: echo "{{ ansible_local.firewallpack_3511_audit }}"
    register: firewallpack
    ignore_errors: True
    tags:
      - firewallpack
      - 3.5.1.1
      - three
      - all
      
  - name: 3.5.1.1 Ensure FirewallD is installed
    yum: 
      name: firewalld  
      state: present
    failed_when: no
    when: firewallpack.stdout.find("FAILED") != -1
    tags: 
      - firewallpack
      - 3.5.1.1
      - three
      - all

  - name: 3.5.1.1 - Ensure a Firewall package is installed
    yum: 
      name: iptables  
      state: present
    failed_when: no
    when: firewallpack.stdout.find("FAILED") != -1
    tags: 
      - firewallpack
      - 3.5.1.1
      - three
      - all

  - name:  3.5.1.2-Fetch the  iptablesservfirewall value from ansible facts
    shell: echo "{{ ansible_local.iptablesservfirewall_3512_audit }}"
    register: iptablesservfirewall
    ignore_errors: True
    tags:
      - iptablesservfirewall
      - 3.5.1.2
      - three
      - all

  - name: 3.5.1.2 - Ensure iptables-services package is not installed
    systemd:
      name: iptables
      state: stopped
    when: iptablesservfirewall.stdout.find("FAILED") != -1
    tags:
      - iptablesservfirewall
      - 3.5.1.2
      - three
      - all      

  - name: 3.5.1.2 - Ensure iptables-services package is not installed
    systemd:
      name: ip6tables
      state: stopped
    when: iptablesservfirewall.stdout.find("FAILED") != -1
    tags:
      - iptablesservfirewall
      - 3.5.1.2
      - three
      - all      

  - name: 3.5.1.2 - Ensure iptables-services package is not installed
    yum:
      name: iptables-services
      state: absent
    when: iptablesservfirewall.stdout.find("FAILED") != -1
    tags:
      - iptablesservfirewall
      - 3.5.1.2
      - three
      - all      

  - name:  3.5.1.3-Fetch the nftablesstop  value from ansible facts
    shell: echo "{{ ansible_local.nftablesstop_3513_audit }}"
    register: nftablesstop
    ignore_errors: True
    tags:
      - nftablesstop
      - 3.5.1.3
      - three
      - all

  - name: 3.5.1.3 - Ensure nftables is not installed or stopped and masked 
    yum:  
      name: nftables
      state: absent
    when: nftablesstop.stdout.find("FAILED") != -1
    tags:
      - nftablesstop
      - 3.5.1.3
      - three
      - all      

#  - name: 3.5.1.3 - Ensure nftables is not installed or stopped and masked 
#    systemd:
#      name: nftables
#      masked: yes
#    when: nftablesstop.stdout.find("FAILED") != -1
#    tags:
#      - nftablesstop
#      - 3.5.1.3
#      - three
#      - all    

  - name:  3.5.1.4-Fetch the  firewallenb value from ansible facts
    shell: echo "{{ ansible_local.firewallenb_3514_audit }}"
    register: firewallenb
    ignore_errors: True
    tags:
      - firewallenb
      - 3.5.1.4
      - three
      - all
      
  - name: 3.5.1.4 - Ensure firewalld service is enabled and running 
    systemd:
      name: firewalld
      masked: no
    failed_when: no
    when: firewallenb.stdout.find("FAILED") != -1
    tags:
      - firewallenb
      - 3.5.1.4
      - three
      - all      

  - name: 3.5.1.4 - Ensure firewalld service is enabled and running 
    systemd:
      name: firewalld
      state: started
      enabled: yes
    failed_when: no
    when: firewallenb.stdout.find("FAILED") != -1
    tags:
      - firewallenb
      - 3.5.1.4
      - three
      - all           

  - name:  3.5.1.5-Fetch the defaultzone  value from ansible facts
    shell: echo "{{ ansible_local.defaultzone_3515_audit }}"
    register: defaultzone
    ignore_errors: True
    tags:
      - defaultzone
      - 3.5.1.5
      - three
      - all

  - name: 3.5.1.5 - Ensure default zone is set
    command: firewall-cmd --set-default-zone={{NAME_OF_ZONE}}
    failed_when: no
    when: defaultzone.stdout.find("FAILED") != -1
    tags:
      - defaultzone
      - 3.5.1.5
      - three
      - all           

  - name:  3.5.1.6-Fetch the netinterface  value from ansible facts 
    shell: echo "{{ ansible_local.netinterface_3516_audit }}"
    register: netinterface
    ignore_errors: True
    tags:
      - netinterface
      - 3.5.1.6
      - three
      - all

  - name: 3.5.1.6 - Ensure network interfaces are assigned to appropriate zone 
    command: firewall-cmd --zone={{zone_name}} --change-interface={{interface_name}}
    failed_when: no
    when: netinterface.stdout.find("FAILED") != -1
    tags:
      - netinterface
      - 3.5.1.6
      - three
      - all           

  - name:  3.5.1.7-Fetch the unnecservport  value from ansible facts
    shell: echo "{{ ansible_local.unnecservport_3517_audit }}"
    register: unnecservport
    ignore_errors: True
    tags:
      - unnecservport
      - 3.5.1.7
      - three
      - all

  - name: 3.5.1.7 - Ensure unnecessary services and ports are not accepted  
    firewalld:
      service: 
      permanent: yes
      state: absent
#     command: firewall-cmd --remove-service=<service>
    failed_when: no
    when: unnecservport.stdout.find("FAILED") != -1
    tags:
      - unnecservport
      - 3.5.1.7
      - three
      - all  

  - name: 3.5.1.7 - Ensure unnecessary services and ports are not accepted  
    firewalld:
      port: 
      permanent: yes
      state: absent
#    command: firewall-cmd --remove-port=<port-number>/<port-type>
    failed_when: no
    when: unnecservport.stdout.find("FAILED") != -1
    tags:
      - unnecservport
      - 3.5.1.7
      - three
      - all        

  - name:  3.5.2.1-Fetch the nftablesins  value from ansible facts
    shell: echo "{{ ansible_local.nftablesins_3521_audit }}"
    register: nftablesins
    ignore_errors: True
    tags:
      - nftablesins
      - 3.5.2.1
      - three
      - all

  - name: 3.5.2.1 - Ensure nftables is installed 
    yum:
      name: nftables
      state: present
    when: nftablesins.stdout.find("FAILED") != -1
    failed_when: no
    tags:
      - nftablesins
      - 3.5.2.1
      - three
      - all

  - name:  3.5.2.2-Fetch the firewallno  value from ansible facts
    shell: echo "{{ ansible_local.firewallno_3522_audit }}"
    register: firewallno
    ignore_errors: True
    tags:
      - firewallno
      - 3.5.2.2
      - three
      - all

#  - name: 3.5.2.2 - Ensure firewalld is not installed or stopped and masked 
#    yum:  
#      name: firewalld
#      state: absent
#    failed_when: no
#    when: firewallno.stdout.find("FAILED") != -1
#    tags:
#      - firewallno
#      - 3.5.2.2
#      - three
#      - all      

  - name: 3.5.2.2 - Ensure firewalld is not installed or stopped and masked
    systemd:
      name: firewalld
      masked: yes
    when: firewallno.stdout.find("FAILED") != -1
    tags:
      - firewallno
      - 3.5.2.2
      - three
      - all      

  - name:  3.5.2.3-Fetch the iptablesservnftables  value from ansible facts
    shell: echo "{{ ansible_local.iptablesservnftables_3523_audit }}"
    register: iptablesservnftables 
    ignore_errors: True
    tags:
      - iptablesservnftables 
      - 3.5.2.3
      - three
      - all

  - name: 3.5.2.3 - Ensure iptables-services package is not installed
    systemd:
      name: iptables
      state: stopped
    failed_when: no
    when: iptablesservnftables.stdout.find("FAILED") != -1
    tags:
      - iptablesservnftables 
      - 3.5.2.3
      - three
      - all

  - name: 3.5.2.3 - Ensure iptables-services package is not installed
    systemd:
      name: ip6tables
      state: stopped
    failed_when: no
    when: iptablesservnftables.stdout.find("FAILED") != -1
    tags:
      - iptablesservnftables 
      - 3.5.2.3
      - three
      - all      

  - name: 3.5.2.3 - Ensure iptables-services package is not installed 
    yum:  
      name: iptables-services
      state: absent
    failed_when: no
    when: iptablesservnftables.stdout.find("FAILED") != -1
    tags:
      - iptablesservnftables 
      - 3.5.2.3
      - three
      - all      

  - name: 3.5.2.4-Fetch the  iptablesflush value from ansible facts
    shell: echo "{{ ansible_local.iptablesflush_3524_audit }}"
    register: iptablesflush
    ignore_errors: True
    tags:
      - iptablesflush
      - 3.5.2.4
      - three
      - all
      
  - name: 3.5.2.4 - Ensure iptables are flushed 
    command: "{{ item }}"
    with_items:
      - iptables -F
      - ip6tables -F
    failed_when: no
    when: iptablesflush.stdout.find("FAILED") != -1
    tags:
      - iptablesflush
      - 3.5.2.4
      - three
      - all      

  - name:  3.5.2.5-Fetch the  tablexists value from ansible facts
    shell: echo "{{ ansible_local.tablexists_3525_audit }}"
    register: tablexists
    ignore_errors: True
    tags:
      - tablexists
      - 3.5.2.5
      - three
      - all
      
  - name: 3.5.2.5 - Ensure a table exists
    command: nft create table inet {{ table_name }}
    failed_when: no
    when: tablexists.stdout.find("FAILED") != -1
    tags:
      - tablexists
      - 3.5.2.5
      - three
      - all

  - name:  3.5.2.6-Fetch the basechains  value from ansible facts
    shell: echo "{{ ansible_local.basechains_3526_audit }}"
    register: basechains
    ignore_errors: True
    tags:
      - basechains
      - 3.5.2.6
      - three
      - all
      
  - name: 3.5.2.6 - Ensure base chains exist
    command: nft create chain inet {{ table_name }} {{ base_chain_name }} { type filter hook {{ base_input_forward_output }} priority 0 \; }
    failed_when: no
    when: basechains.stdout.find("FAILED") != -1
    tags:
      - basechains
      - 3.5.2.6
      - three
      - all      

  - name:  3.5.2.7-Fetch the nfloopbacktraffic  value from ansible facts
    shell: echo "{{ ansible_local.nfloopbacktraffic_3527_audit }}"
    register: nfloopbacktraffic
    ignore_errors: True
    tags:
      - nfloopbacktraffic
      - 3.5.2.7
      - three
      - all
      
  - name: 3.5.2.7 - Ensure loopback traffic is configured
    command: "{{ item }}"
    with_items: 
      - nft add rule inet filter input iif lo accept
      - nft create rule inet filter input ip saddr 127.0.0.0/8 counter drop
      - nft add rule inet filter INPUT ip6 saddr ::1 counter drop
    failed_when: no
    when: nfloopbacktraffic.stdout.find("FAILED") != -1
    tags: 
      - nfloopbacktraffic
      - 3.5.2.7
      - three
      - all      

  - name: 3.5.2.8 -Fetch the  nfoutbound value from ansible facts
    shell: echo "{{ ansible_local.nfoutbound_3528_audit }}"
    register: nfoutbound
    ignore_errors: True
    tags:
      - nfoutbound
      - 3.5.2.8
      - three
      - all
      
  - name: 3.5.2.8 - Ensure outbound and established connections are configured 
    command: "{{ item }}"
    with_items: 
      - nft add rule inet filter input ip protocol tcp ct state established accept
      - nft add rule inet filter input ip protocol udp ct state established accept
      - nft add rule inet filter input ip protocol icmp ct state established accept
      - nft add rule inet filter output ip protocol tcp ct state new,related,established accept
      - nft add rule inet filter output ip protocol udp ct state new,related,established accept
      - nft add rule inet filter output ip protocol icmp ct state new,related,established accept
    failed_when: no
    when: nfoutbound.stdout.find("FAILED") != -1
    tags:
      - nfoutbound
      - 3.5.2.8
      - three
      - all      

  - name:  3.5.2.9-Fetch the nffirewallpolicy  value from ansible facts
    shell: echo "{{ ansible_local.nffirewallpolicy_3529_audit }}"
    register: nffirewallpolicy
    ignore_errors: True
    tags:
      - nffirewallpolicy
      - 3.5.2.9
      - three
      - all
      
  - name: 3.5.2.9 Ensure default deny firewall policy 
    command: nft chain <table family> <table name> <chain name> { policy drop \; }
    failed_when: no
    when: nffirewallpolicy.stdout.find("FAILED") != -1
    tags:
      - nffirewallpolicy
      - 3.5.2.9
      - three
      - all

  - name:  3.5.2.10-Fetch the nftablesenb  value from ansible facts
    shell: echo "{{ ansible_local.nftablesenb_35210_audit }}"
    register: nftablesenb
    ignore_errors: True
    tags:
      - nftablesenb
      - 3.5.2.10
      - three
      - all
 
  - name: 3.5.2.10 - Ensure nftables service is enabled
    yum:
      name: nftables
      state: present
    when: nftablesenb.stdout.find("FAILED") != -1
    tags:
      - nftablesenb
      - 3.5.2.10
      - three
      - all
     
  - name: 3.5.2.10 - Ensure nftables service is enabled
    service:    
      name: nftables
      enabled: yes
    failed_when: no
    when: nftablesenb.stdout.find("FAILED") != -1
    tags: 
      - nftablesenb
      - 3.5.2.10
      - three
      - all

  - name:  3.5.2.11-Fetch the nftablesrules  value from ansible facts
    shell: echo "{{ ansible_local.nftablesrules_35211_audit }}"
    register: nftablesrules
    ignore_errors: True
    tags:
      - nftablesrules
      - 3.5.2.11
      - three
      - all
      
  - name: 3.5.2.11 - Ensure nftables rules are permanent
    lineinfile:
      path: /etc/sysconfig/nftables.conf
      line: 'include "/etc/nftables/nftables.rules"'
      state: present
    failed_when: no
    when: nftablesrules.stdout.find("FAILED") != -1
    tags:
      - nftablesrules
      - 3.5.2.11
      - three
      - all

  - name:  3.5.3.1.1-Fetch the iptables  value from ansible facts
    shell: echo "{{ ansible_local.iptables_35311_audit }}"
    register: iptables
    ignore_errors: True
    tags:
      - iptables 
      - 3.5.3.1.1
      - three
      - all
      
  - name: 3.5.3.1.1 - Ensure iptables packages are installed
    yum:
      name:
        - iptables 
        - iptables-services
      state: present
    failed_when: no
    when: iptables.stdout.find("FAILED") != -1
    tags:
      - iptables
      - 3.5.3.1.1
      - three
      - all      

  - name:  3.5.3.1.2-Fetch the  nftablesstopdup value from ansible facts
    shell: echo "{{ ansible_local.nftablesstopdup_35312_audit }}"
    register: nftablesstopdup 
    ignore_errors: True
    tags:
      - nftablesstopdup 
      - 3.5.3.1.2
      - three
      - all
      
  - name: 3.5.3.1.2 - Ensure nftables is not installed
    yum: 
      name: nftables
      state: absent
    failed_when: no
    when: nftablesstopdup.stdout.find("FAILED") != -1
    tags:
      - nftablesstopdup
      - 3.5.3.1.2
      - three
      - all

  - name:  3.5.3.1.3-Fetch the firewallnodup  value from ansible facts
    shell: echo "{{ ansible_local.firewallnodup_35313_audit }}"
    register: firewallnodup
    ignore_errors: True
    tags:
      - firewallnodup 
      - 3.5.3.1.3
      - three
      - all

  - name: 3.5.3.1.3 - Ensure firewalld is not installed or stopped and masked 
    yum:  
      name: firewalld
      state: absent
    when: firewallnodup.stdout.find("FAILED") != -1
    tags:
      - firewallnodup
      - 3.5.3.1.3
      - three
      - all      

#  - name: 3.5.3.1.3 - Ensure firewalld is not installed or stopped and masked
#    systemd:
#      name: firewalld
#      masked: yes
#    when: firewallnodup.stdout.find("FAILED") != -1
#    tags:
#      - firewallnodup
#      - 3.5.3.1.3
#      - three
#      - all      

#  - name:  3.5.3.2.1-Fetch the  firewallpolicyip value from ansible facts
#    shell: echo "{{ ansible_local.firewallpolicyip_35321_audit }}"
#    register: firewallpolicyip
#    ignore_errors: True
#    tags:
#      - firewallpolicyip
#      - 3.5.3.2.1
#      - three
#      - all
      
#  - name: 3.5.3.2.1 - Ensure default deny firewall policy
#    command: "{{ item }}"
#    with_items:
#      - iptables -P INPUT DROP
#      - iptables -P OUTPUT DROP
#      - iptables -P FORWARD DROP
#    failed_when: no
#    when: firewallpolicyip.stdout.find("FAILED") != -1
#    tags:
#      - firewallpolicyip
#      - 3.5.3.2.1
#      - three
#      - all      

  - name:  3.5.3.2.2-Fetch the loopbacktraffic  value from ansible facts
    shell: echo "{{ ansible_local.loopbacktraffic_35322_audit }}"
    register: loopbacktraffic
    ignore_errors: True
    tags:
      - loopbacktraffic
      - 3.5.3.2.2
      - three
      - all
      
  - name: 3.5.3.2.2 - Ensure loopback traffic is configured
    command: "{{ item }}"
    with_items:
      - iptables -A INPUT -i lo -j ACCEPT
      - iptables -A OUTPUT -o lo -j ACCEPT
      - iptables -A INPUT -s 127.0.0.0/8 -j DROP
    failed_when: no
    when: loopbacktraffic.stdout.find("FAILED") != -1
    tags:
      - loopbacktraffic
      - 3.5.3.2.2
      - three
      - all
    
  - name:  3.5.3.2.3-Fetch the  outbound value from ansible facts
    shell: echo "{{ ansible_local.outbound_35323_audit }}"
    register: outbound
    ignore_errors: True
    tags:
      - outbound
      - 3.5.3.2.3
      - three
      - all
      
  - name: 3.5.3.2.3 Ensure outbound and established connections are configured
    command: "{{ item }}"
    with_items:
      - iptables -A OUTPUT -p tcp -m state --state NEW,ESTABLISHED -j ACCEPT
      - iptables -A OUTPUT -p udp -m state --state NEW,ESTABLISHED -j ACCEPT
      - iptables -A OUTPUT -p icmp -m state --state NEW,ESTABLISHED -j ACCEPT
      - iptables -A INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT
      - iptables -A INPUT -p udp -m state --state ESTABLISHED -j ACCEPT
      - iptables -A INPUT -p icmp -m state --state ESTABLISHED -j ACCEPT
    failed_when: no
    when: outbound.stdout.find("FAILED") != -1
    tags:
      - outbound
      - 3.5.3.2.3
      - three
      - all

  - name:  3.5.3.2.4-Fetch the firewallrules  value from ansible facts
    shell: echo "{{ ansible_local.firewallrules_35324_audit }}"
    register: firewallrules
    ignore_errors: True
    tags:
      - firewallrules
      - 3.5.3.2.4
      - three
      - all
      
  - name: 3.5.3.2.4 - Ensure firewall rules exist for all open ports
    shell: "netstat -lnt | grep '0:[0-9]' | cut -d: -f2 | cut -d' ' -f1"
    register: tcpecho
    when: firewallrules.stdout.find("FAILED") != -1
    tags:
      - firewallrules
      - 3.5.3.2.4
      - three
      - all

  - name: 3.5.3.2.4 - Ensure firewall rules exist for all open ports
    iptables:
      chain: INPUT
      protocol: tcp
      match: state
      destination_port: "{{ item }}"
      ctstate: NEW
      jump: ACCEPT
    loop: "{{ tcpecho.stdout_lines }}"
    when: firewallrules.stdout.find("FAILED") != -1
    tags:
      - firewallrules
      - 3.5.3.2.4
      - three
      - all

  - name: 3.5.3.2.4 - Ensure firewall rules exist for all open ports
    iptables:
      chain: OUTPUT
      protocol: tcp
      match: state
      destination_port: "{{ item }}"
      ctstate: NEW
      jump: ACCEPT
    loop: "{{ tcpecho.stdout_lines }}"
    when: firewallrules.stdout.find("FAILED") != -1
    tags:
      - firewallrules
      - 3.5.3.2.4
      - three
      - all

  - name: 3.5.3.2.4 - Ensure firewall rules exist for all open ports
    shell: "netstat -lnu | grep ^udp | grep LISTEN | awk {'print $4'} | cut -d':' -f2"
    register: udpecho
    when: firewallrules.stdout.find("FAILED") != -1
    tags:
      - firewallrules
      - 3.5.3.2.4
      - three
      - all

  - name: 3.5.3.2.4 - Ensure firewall rules exist for all open ports
    iptables:
      chain: INPUT
      protocol: udp
      match: state
      destination_port: "{{ item }}"
      ctstate: NEW
      jump: ACCEPT
    loop: "{{ udpecho.stdout_lines }}"
    when: firewallrules.stdout.find("FAILED") != -1
    tags:
      - firewallrules
      - 3.5.3.2.4
      - three
      - all

  - name:  3.5.3.2.5-Fetch the   value from ansible facts
    shell: echo "{{ ansible_local.iptablesrules_35325_audit }}"
    register: iptablesrules
    ignore_errors: True
    tags:
      - iptablesrules
      - 3.5.3.2.5
      - three
      - all
      
  - name: 3.5.3.2.5 - Ensure iptables rules are saved
    command: iptables -L
    failed_when: no
    when: iptablesrules.stdout.find("FAILED") != -1
    tags:
      - iptablesrules
      - 3.5.3.2.5
      - three
      - all

  - name: 3.5.3.2.5 - Ensure iptables rules are saved
    command: service iptables save
    failed_when: no
    when: iptablesrules.stdout.find("FAILED") != -1
    tags:
      - iptablesrules
      - 3.5.3.2.5
      - three
      - all      

  - name:  3.5.3.2.6-Fetch the iptablesenb  value from ansible facts
    shell: echo "{{ ansible_local.iptablesenb_35326_audit }}"
    register: iptablesenb
    ignore_errors: True
    tags:
      - iptablesenb
      - 3.5.3.2.6
      - three
      - all
      
  - name: 3.5.3.2.6 - Ensure iptables is enabled and running
    service:
      name: iptables
      state: restarted
      enabled: yes
    failed_when: no
    when: iptablesenb.stdout.find("FAILED") != -1
    tags:
      - iptablesenb
      - 3.5.3.2.6
      - three
      - all      

  - name:  3.5.3.3.1-Fetch the ipv6firewallpolicy  value from ansible facts
    shell: echo "{{ ansible_local.ipv6firewallpolicy_35331_audit }}"
    register: ipv6firewallpolicy
    ignore_errors: True
    tags:
      - ipv6firewallpolicy
      - 3.5.3.3.1
      - three
      - all
      
  - name: 3.5.3.3.1 - Ensure IPv6 default deny firewall policy
    command: "{{item}}"
    with_items:
      - ip6tables -P INPUT DROP
      - ip6tables -P OUTPUT DROP
      - ip6tables -P FORWARD DROP
    failed_when: no
    when: ipv6firewallpolicy.stdout.find("FAILED") != -1
    tags:
      - ipv6firewallpolicy
      - 3.5.3.3.1
      - three
      - all

  - name:  3.5.3.3.2-Fetch the ipv6loopbacktraffic  value from ansible facts
    shell: echo "{{ ansible_local.ipv6loopbacktraffic_35332_audit }}"
    register: ipv6loopbacktraffic
    ignore_errors: True
    tags:
      - ipv6loopbacktraffic
      - 3.5.3.3.2
      - three
      - all
      
  - name: 3.5.3.3.2 - Ensure IPv6 loopback traffic is configured
    command: "{{item}}"
    with_items:
      - ip6tables -A INPUT -i lo -j ACCEPT
      - ip6tables -A OUTPUT -o lo -j ACCEPT
      - ip6tables -A INPUT -s ::1 -j DROP
    failed_when: no
    when: ipv6loopbacktraffic.stdout.find("FAILED") != -1
    tags:
      - ipv6loopbacktraffic
      - 3.5.3.3.2
      - three
      - all
  
  - name:  3.5.3.3.3-Fetch the ipv6outbound  value from ansible facts
    shell: echo "{{ ansible_local.ipv6outbound_35333_audit }}"
    register: ipv6outbound
    ignore_errors: True
    tags:
      - ipv6outbound
      - 3.5.3.3.3
      - three
      - all
      
  - name: 3.5.3.3.3 - Ensure IPv6 outbound and established connections are configured
    command: "{{ item }}"
    with_items:
      - ip6tables -A OUTPUT -p tcp -m state --state NEW,ESTABLISHED -j ACCEPT
      - ip6tables -A OUTPUT -p udp -m state --state NEW,ESTABLISHED -j ACCEPT
      - ip6tables -A OUTPUT -p icmp -m state --state NEW,ESTABLISHED -j ACCEPT
      - ip6tables -A INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT
      - ip6tables -A INPUT -p udp -m state --state ESTABLISHED -j ACCEPT
      - ip6tables -A INPUT -p icmp -m state --state ESTABLISHED -j ACCEPT
    failed_when: no
    when: ipv6outbound.stdout.find("FAILED") != -1
    tags:
      - ipv6outbound
      - 3.5.3.3.3
      - three
      - all

  - name:  3.5.3.3.4-Fetch the ipv6firewallrules  value from ansible facts
    shell: echo "{{ ansible_local.ipv6firewallrules_35334_audit }}"
    register: ipv6firewallrules
    ignore_errors: True
    tags:
      - ipv6firewallrules
      - 3.5.3.3.4
      - three
      - all
      
  - name: 3.5.3.3.4 - Ensure IPv6 firewall rules exist for all open ports
    command: ip6tables -A INPUT -p <protocol> --dport <port> -m state --state NEW -j ACCEPT
    failed_when: no
    when: ipv6firewallrules.stdout.find("FAILED") != -1
    tags:
      - ipv6firewallrules
      - 3.5.3.3.4
      - three
      - all      
      
  - name:  3.5.3.3.5-Fetch the   value from ansible facts
    shell: echo "{{ ansible_local.rulesaresaved_35335_audit }}"
    register: rulesaresaved
    ignore_errors: True
    tags:
      - rulesaresaved
      - 3.5.3.3.5
      - three
      - all
      
  - name: 3.5.3.3.5 - Ensure ip6tables rules are saved
    command: ip6tables -L
    failed_when: no
    when: rulesaresaved.stdout.find("FAILED") != -1
    tags:
      - rulesaresaved
      - 3.5.3.3.5
      - three
      - all

  - name: 3.5.3.3.5 - Ensure ip6tables rules are saved
    command: service ip6tables save
    failed_when: no
    when: rulesaresaved.stdout.find("FAILED") != -1
    tags:
      - rulesaresaved
      - 3.5.3.3.5
      - three
      - all      

  - name:  3.5.3.3.6-Fetch the ip6tablesenb  value from ansible facts
    shell: echo "{{ ansible_local.ip6tablesenb_35336_audit }}"
    register: ip6tablesenb
    ignore_errors: True
    tags:
      - ip6tablesenb
      - 3.5.3.3.6
      - three
      - all
      
  - name: 3.5.3.3.6 - Ensure ip6tables is enabled and running
    command: systemctl --now start ip6tables
    failed_when: no
    when: ip6tablesenb.stdout.find("FAILED") != -1
    tags:
      - ip6tablesenb
      - 3.5.3.3.6
      - three
      - all      

  - name:  4.1.1.1-Fetch the  auditd value from ansible facts
    shell: echo "{{ ansible_local.auditd_4111_audit }}" 
    register: auditd
    ignore_errors: True
    tags:
      - auditd
      - 4.1.1.1
      - four
      - all
 
  - name: 4.1.1.1 - Ensure auditd is installed
    yum:
      name: audit
      state: present
    failed_when: no
    when: auditd.stdout.find("FAILED") != -1
    tags:
      - auditd
      - 4.1.1.1
      - four
      - all

  - name: 4.1.1.1 - Ensure auditd is installed
    yum:
      name: audit-libs
      state: present
    failed_when: no
    when: auditd.stdout.find("FAILED") != -1
    tags:
      - auditd
      - 4.1.1.1
      - four
      - all      

  - name:  4.1.1.2-Fetch the auditdservice  value from ansible facts
    shell: echo "{{ ansible_local.auditdservice_4112_audit }}" 
    register: auditdservice
    ignore_errors: True
    tags:
      - auditdservice
      - 4.1.1.2
      - four
      - all
      
  - name: 4.1.1.2 - Ensure auditd service is enabled and running
    service:
      name: auditd
      enabled: yes
    failed_when: no
    when: auditdservice.stdout.find("FAILED") != -1
    tags:
      - auditdservice
      - 4.1.1.2
      - four
      - all

  - name:  4.1.1.3-Fetch the auditdenable  value from ansible facts
    shell: echo "{{ ansible_local.auditdenable_4113_audit }}" 
    register: auditdenable
    ignore_errors: True
    tags:
      - auditdenable
      - 4.1.1.3
      - four
      - all
      
  - name: 4.1.1.3 - Ensure auditing for processes that start prior to auditd is enabled
    command: sed -i 's/GRUB_CMDLINE_LINUX="[^"]*/& audit=1/' /etc/default/grub
    failed_when: no
    when: auditdenable.stdout.find("FAILED") != -1 
    tags:
      - auditdenable
      - 4.1.1.3
      - four
      - all

  - name: 4.1.1.3 - Ensure auditing for processes that start prior to auditd is enabled
    command: grub2-mkconfig -o /boot/grub2/grub.cfg
    ignore_errors: yes
    when: auditdenable.stdout.find("FAILED") != -1 
    tags:
      - auditdenable
      - 4.1.1.3
      - four
      - all      

  - name:  4.1.2.1-Fetch the auditlogsize  value from ansible facts
    shell: echo "{{ ansible_local.auditlogsize_4121_audit }}" 
    register: auditlogsize
    ignore_errors: True
    tags:
      - auditlogsize
      - 4.1.2.1
      - four
      - all
      
  - name: 4.1.2.1 - Ensure audit log storage size is configured
    lineinfile:
      path: /etc/audit/auditd.conf
      state: present
      regexp: "^(max_log_file =*|#max_log_file =*)"
      line: "max_log_file = 8"
    failed_when: no
    when: auditlogsize.stdout.find("FAILED") != -1
    tags:
      - auditlogsize
      - 4.1.2.1
      - four
      - all      

  - name:  4.1.2.2-Fetch the auditlogdelete  value from ansible facts
    shell: echo "{{ ansible_local.auditlogdelete_4122_audit }}" 
    register: auditlogdelete
    ignore_errors: True
    tags:
      - auditlogdelete
      - 4.1.2.2
      - four
      - all
      
  - name: 4.1.2.2 - Ensure audit logs are not automatically deleted
    lineinfile:
      path: /etc/audit/auditd.conf
      state: present
      regexp: "^(max_log_file_action =*|#max_log_file_action =*)"
      line: 'max_log_file_action = keep_logs'
    failed_when: no
    when: auditlogdelete.stdout.find("FAILED") != -1
    tags:
      - auditlogdelete
      - 4.1.2.2
      - four
      - all      

  - name: 4.1.2.3 - Fetch the sysdisable value from ansible facts
    shell: echo "{{ ansible_local.sysdisable_4123_audit }}" 
    register: sysdisable
    ignore_errors: True
    tags:
      - sysdisable
      - 4.1.2.3
      - four
      - all
      
  - name: 4.1.2.3 - Ensure system is disabled when audit logs are full
    lineinfile:
      path: /etc/audit/auditd.conf
      state: present
      regexp: "^(space_left_action =*|#space_left_action =*)"
      line: 'space_left_action = email'
    failed_when: no
    when: sysdisable.stdout.find("FAILED") != -1
    tags:
      - sysdisable
      - 4.1.2.3
      - four
      - all
      
  - name: 4.1.2.3 - Ensure system is disabled when audit logs are full
    lineinfile:
      path: /etc/audit/auditd.conf
      state: present
      regexp: "^(action_mail_acct =*|#action_mail_acct =*)"
      line: 'action_mail_acct = root'
    failed_when: no
    when: sysdisable.stdout.find("FAILED") != -1
    tags:
      - sysdisable
      - 4.1.2.3
      - four
      - all

  - name: 4.1.2.3 - Ensure system is disabled when audit logs are full
    lineinfile:
      path: /etc/audit/auditd.conf
      state: present
      regexp: "^(admin_space_left_action =*|#admin_space_left_action =*)"
      line: 'admin_space_left_action = halt'
    failed_when: no
    when: sysdisable.stdout.find("FAILED") != -1
    tags:
      - sysdisable
      - 4.1.2.3
      - four
      - all

  - name:  4.1.2.4-Fetch the auditdbacklog  value from ansible facts
    shell: echo "{{ ansible_local.auditdbacklog_4124_audit }}" 
    register: auditdbacklog
    ignore_errors: True
    tags:
      - auditdbacklog
      - 4.1.2.4
      - four
      - all
      
  - name: 4.1.2.4 - Ensure audit_backlog_limit is sufficient
    command: sed -i 's/GRUB_CMDLINE_LINUX="[^"]*/& audit_backlog_limit=8192/' /etc/default/grub
    failed_when: no
    when: auditdbacklog.stdout.find("FAILED") != -1 
    tags:
      - auditdbacklog
      - 4.1.2.4
      - four
      - all

  - name: 4.1.2.4 - Ensure audit_backlog_limit is sufficient
    command: grub2-mkconfig -o /boot/grub2/grub.cfg
    ignore_errors: yes
    when: auditdbacklog.stdout.find("FAILED") != -1 
    tags:
      - auditdbacklog
      - 4.1.2.4
      - four
      - all      

  - name:  4.1.3-Fetch the moddatetime  value from ansible facts
    shell: echo "{{ ansible_local.moddatetime_413_audit }}" 
    register: moddatetime
    ignore_errors: True
    tags:
      - moddatetime
      - 4.1.3
      - four
      - all
      
  - name: 4.1.3 - Ensure events that modify date and time information are collected
    lineinfile:
      path: /etc/audit/rules.d/time_change.rules
      state: present
      line: "{{item}}"
      create: yes
    with_items:
      - "-a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time-change"
      - "-a always,exit -F arch=b32 -S clock_settime -k time-change"
      - "-w /etc/localtime -p wa -k time-change"
    when: 
      - moddatetime.stdout.find("FAILED") != -1
      - ansible_architecture != "x86_64"
    tags:
      - moddatetime
      - 4.1.3
      - four
      - all
      
  - name: 4.1.3 - Ensure events that modify date and time information are collected
    lineinfile:
      path: /etc/audit/rules.d/time_change.rules
      state: present
      line: "{{item}}"
      create: yes
    with_items:
      - "-a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time-change"
      - "-a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time-change"
      - "-a always,exit -F arch=b64 -S clock_settime -k time-change"
      - "-a always,exit -F arch=b32 -S clock_settime -k time-change"
      - "-w /etc/localtime -p wa -k time-change"
    when: 
      - moddatetime.stdout.find("FAILED") != -1
      - ansible_architecture == "x86_64"
    tags:
      - moddatetime
      - 4.1.3
      - four
      - all
   
  - name: 4.1.3 - Ensure events that modify date and time information are collected
    command: service auditd restart
    failed_when: no
    when: moddatetime.stdout.find("FAILED") != -1
    tags:
      - moddatetime
      - 4.1.3
      - four
      - all

  - name:  4.1.4-Fetch the  modusergrp value from ansible facts
    shell: echo "{{ ansible_local.modusergrp_414_audit }}" 
    register: modusergrp
    ignore_errors: True
    tags:
      - modusergrp
      - 4.1.4
      - four
      - all
      
  - name: 4.1.4 - Ensure  events that modify user/group information are collected
    lineinfile:
      path: /etc/audit/rules.d/identity.rules
      state: present
      line: "{{item}}"
      create: yes
    with_items:
      - "-w /etc/group -p wa -k identity"
      - "-w /etc/passwd -p wa -k identity"
      - "-w /etc/gshadow -p wa -k identity"
      - "-w /etc/shadow -p wa -k identity"
      - "-w /etc/security/opasswd -p wa -k identity"
    when: modusergrp.stdout.find("FAILED") != -1
    tags:
      - modusergrp
      - 4.1.4
      - four
      - all

  - name:  4.1.5-Fetch the modsysnet  value from ansible facts
    shell: echo "{{ ansible_local.modsysnet_415_audit }}" 
    register: modsysnet
    become: yes
    ignore_errors: True
    tags:
      - modsysnet
      - 4.1.5
      - four
      - all
  
  - name: 4.1.5 - Ensure events that modify the system's network environment are collected
    file: path=/etc/audit/rules.d/system_local.rules state=touch owner=root group=root mode=0600
    when: modsysnet.stdout.find("FAILED") != -1    
    tags:
      - modsysnet
      - 4.1.5
      - four
      - all

  - name: 4.1.5 - Ensure events that modify the system's network environment are collected
    lineinfile:
      path: /etc/audit/rules.d/system_local.rules
      state: present
      line: "{{item}}"
      create: yes      
    with_items:
      - "-a always,exit -F arch=b32 -S sethostname -S setdomainname -k system-locale"
      - "-w /etc/issue -p wa -k system-locale"
      - "-w /etc/issue.net -p wa -k system-locale"
      - "-w /etc/hosts -p wa -k system-locale"
      - "-w /etc/network -p wa -k system-locale"
    when:
      - modsysnet.stdout.find("FAILED") != -1
      - ansible_architecture != "x86_64"
    tags:
      - modsysnet
      - 4.1.5
      - four
      - all
      
  - name: 4.1.5 - Ensure events that modify the system's network environment are collected
    lineinfile:
      path: /etc/audit/rules.d/system_local.rules
      state: present
      line: "{{item}}"
      create: yes
    with_items:
      - "-a always,exit -F arch=b64 -S sethostname -S setdomainname -k system-locale"
      - "-a always,exit -F arch=b32 -S sethostname -S setdomainname -k system-locale"
      - "-w /etc/issue -p wa -k system-locale"
      - "-w /etc/issue.net -p wa -k system-locale"
      - "-w /etc/hosts -p wa -k system-locale"
      - "-w /etc/network -p wa -k system-locale"
    when:
     - modsysnet.stdout.find("FAILED") != -1
     - ansible_architecture == "x86_64"
    tags:
      - modsysnet
      - 4.1.5
      - four
      - all

  - name:  4.1.6-Fetch the modsysmac  value from ansible facts
    shell: echo "{{ ansible_local.modsysmac_416_audit }}" 
    register: modsysmac
    ignore_errors: True
    tags:
      - modsysmac
      - 4.1.6
      - four
      - all
 
  - name: 4.1.6 - Ensure events that modify the system's Mandatory Access Controls are collected
    file: path=/etc/audit/rules.d/MAC_policy.rules state=touch owner=root group=root mode=0600
    when: modsysmac.stdout.find("FAILED") != -1
    tags:
      - modsysmac
      - 4.1.6
      - four
      - all
     
  - name: 4.1.6 - Ensure events that modify the system's Mandatory Access Controls are collected
    lineinfile:
      path: /etc/audit/rules.d/MAC_policy.rules
      state: present
      line: "{{item}}"
      create: yes
    with_items:
      - "-w /etc/selinux/ -p wa -k MAC-policy"
      - "-w /usr/share/selinux/ -p wa -k MAC-policy"
    when: modsysmac.stdout.find("FAILED") != -1
    tags:
      - modsysmac
      - 4.1.6
      - four
      - all
      
  - name: 4.1.6 - Ensure events that modify the system's Mandatory Access Controls are collected
    command: service auditd restart
    failed_when: no
    when: modsysmac.stdout.find("FAILED") != -1
    tags:
      - modsysmac
      - 4.1.6
      - four
      - all

  - name:  4.1.7-Fetch the  loginout value from ansible facts
    shell: echo "{{ ansible_local.loginout_417_audit }}" 
    register: loginout
    ignore_errors: True
    tags:
      - loginout
      - 4.1.7
      - four
      - all

  - name: 4.1.7 - Ensure login and logout events are collected
    lineinfile:
      path: /etc/audit/rules.d/logins.rules
      state: present
      line: "{{item}}"
      create: yes
    with_items:
      - "-w /var/log/lastlog -p wa -k logins"
      - "-w /var/run/faillog -p wa -k logins"
    when: loginout.stdout.find("FAILED") != -1
    tags:
      - loginout
      - 4.1.7
      - four
      - all

  - name: 4.1.7 - Ensure login and logout events are collected
    command: service auditd restart
    failed_when: no
    when: loginout.stdout.find("FAILED") != -1
    tags:
      - loginout
      - 4.1.7
      - four
      - all

  - name:  4.1.8-Fetch the session  value from ansible facts
    shell: echo "{{ ansible_local.session_418_audit }}" 
    register: session
    ignore_errors: True
    tags:
      - session
      - 4.1.8
      - four
      - all
     
  - name: 4.1.8 - Ensure session initiation information is collected
    lineinfile:
      path: /etc/audit/rules.d/session.rules
      state: present
      line: "{{item}}"
      create: yes
    with_items:
      - "-w /var/run/utmp -p wa -k session"
      - "-w /var/log/wtmp -p wa -k logins"
      - "-w /var/log/btmp -p wa -k logins"
    when: session.stdout.find("FAILED") != -1
    tags:
      - session
      - 4.1.8
      - four
      - all
      
  - name: 4.1.8 - Ensure session initiation information is collected
    command: service auditd restart
    failed_when: no
    when: session.stdout.find("FAILED") != -1
    tags:
      - session
      - 4.1.8
      - four
      - all

  - name:  4.1.9-Fetch the dacperm  value from ansible facts
    shell: echo "{{ ansible_local.dacperm_419_audit }}" 
    register: dacperm
    ignore_errors: True
    tags:
      - dacperm
      - 4.1.9
      - four
      - all
      
  - name: 4.1.9 - Ensure discretionary access control permission modification events are collected
    lineinfile:
      path: /etc/audit/rules.d/perm_mod.rules
      state: present
      line: "{{item}}"
      create: yes
    with_items:
      - "-a always,exit -F arch=b32 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod"
      - "-a always,exit -F arch=b32 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod"
      - "-a always,exit -F arch=b32 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295"
      - "-k perm_mod"
    when:
     - dacperm.stdout.find("FAILED") != -1
     - ansible_architecture != "x86_64"
    tags:
      - dacperm
      - 4.1.9
      - four
      - all
      
  - name: 4.1.9 - Ensure discretionary access control permission modification events are collected
    lineinfile:
      path: /etc/audit/rules.d/perm_mod.rules
      state: present
      line: "{{item}}"
      create: yes
    with_items:
      - "-a always,exit -F arch=b64 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod"
      - "-a always,exit -F arch=b32 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod"
      - "-a always,exit -F arch=b64 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod"
      - "-a always,exit -F arch=b32 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod"
      - "-a always,exit -F arch=b64 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod"
      - "-a always,exit -F arch=b32 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod"
    when:
      - dacperm.stdout.find("FAILED") != -1
      - ansible_architecture == "x86_64"
    tags:
      - dacperm
      - 4.1.9
      - four
      - all
      
  - name: 4.1.9 - Ensure discretionary access control permission modification events are collected
    command: service auditd restart
    failed_when: no
    when: dacperm.stdout.find("FAILED") != -1
    tags:
      - dacperm
      - 4.1.9
      - four
      - all

  - name:  4.1.10-Fetch the  fileaccess value from ansible facts
    shell: echo "{{ ansible_local.fileaccess_4110_audit }}" 
    register: fileaccess
    ignore_errors: True
    tags:
      - fileaccess
      - 4.1.10
      - four
      - all
    
  - name: 4.1.10 - Ensure unsuccessful unauthorized file access attempts are collected
    lineinfile:
      path: /etc/audit/rules.d/access.rules
      state: present
      line: "{{item}}"
      create: yes      
    with_items:
      - "-a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access"
      - "-a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access"
    when:
      - fileaccess.stdout.find("FAILED") != -1
      - ansible_architecture != "x86_64"
    tags:
      - fileaccess
      - 4.1.10
      - four
      - all
    
  - name: 4.1.10 - Ensure unsuccessful unauthorized file access attempts are collected
    lineinfile:
      path: /etc/audit/rules.d/access.rules
      state: present
      line: "{{item}}"
      create: yes
    with_items:
      - "-a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access"
      - "-a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access"
      - "-a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access"
      - "-a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access"
    when:
      - fileaccess.stdout.find("FAILED") != -1
      - ansible_architecture == "x86_64"
    tags:
      - fileaccess
      - 4.1.10
      - four
      - all
      
  - name: 4.1.10 - Ensure unsuccessful unauthorized file access attempts are collected
    command: service auditd restart
    failed_when: no
    when: fileaccess.stdout.find("FAILED") != -1
    tags:
      - fileaccess
      - 4.1.10
      - four
      - all

  - name:  4.1.11-Fetch the  privilegecmd value from ansible facts
    shell: echo "{{ ansible_local.privilegecmd_4111_audit }}" 
    register: privilegecmd
    ignore_errors: True
    tags:
      - privilegecmd
      - 4.1.11
      - four
      - all
      
  - name: 4.1.11 - Ensure use of privileged commands is collected
    shell: find / -xdev \( -perm -4000 -o -perm -2000 \) -type f | awk '{print "-a always,exit -F path=" $1 " -F perm=x -F auid>='"$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"' -F auid!=4294967295 -k privileged" }' >> /etc/audit/rules.d/privileged.rules
    when: privilegecmd.stdout.find("FAILED") != -1
    tags:
      - privilegecmd
      - 4.1.11
      - four
      - all

  - name: 4.1.11 - Ensure use of privileged commands is collected    
    command: service auditd restart
    failed_when: no
    when: privilegecmd.stdout.find("FAILED") != -1
    tags:
      - privilegecmd
      - 4.1.11
      - four
      - all
      
  - name:  4.1.12-Fetch the fsmount  value from ansible facts
    shell: echo "{{ ansible_local.fsmount_4112_audit }}" 
    register: fsmount
    ignore_errors: True
    tags:
      - fsmount
      - 4.1.12
      - four
      - all
      
  - name: 4.1.12 - Ensure successful file system mounts are collected
    lineinfile:
      path: /etc/audit/rules.d/audit.rules
      state: present
      line: "-a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts"
    when:
      - fsmount.stdout.find("FAILED") != -1
      - ansible_architecture != "x86_64"
    tags:
      - fsmount
      - 4.1.12
      - four
      - all

  - name: 4.1.12 - Ensure successful file system mounts are collected
    file: path=/etc/audit/rules.d/mounts.rules state=touch owner=root group=root mode=0600
    when: fsmount.stdout.find("FAILED") != -1
    tags:
      - fsmount
      - 4.1.12
      - four
      - all
  
  - name: 4.1.12 - Ensure successful file system mounts are collected
    lineinfile:
      path: /etc/audit/rules.d/mounts.rules
      state: present
      line: "{{item}}"
    with_items:
      - "-a always,exit -F arch=b64 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts"
      - "-a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts"
    when:
      - fsmount.stdout.find("FAILED") != -1
      - ansible_architecture == "x86_64"
    tags:
      - fsmount
      - 4.1.12
      - four
      - all
    
  - name: 4.1.12 - Ensure successful file system mounts are collected
    command: service auditd restart
    failed_when: no
    when: fsmount.stdout.find("FAILED") != -1
    tags:
      - fsmount
      - 4.1.12
      - four
      - all

  - name:  4.1.13-Fetch the filedeletion  value from ansible facts
    shell: echo "{{ ansible_local.filedeletion_4113_audit }}" 
    register: filedeletion
    ignore_errors: True
    tags:
      - filedeletion
      - 4.1.13
      - four
      - all

  - name: 4.1.13 - Ensure file deletion events by users are collected
    file: path=/etc/audit/rules.d/deletion.rules state=touch owner=root group=root mode=0600
    when: filedeletion.stdout.find("FAILED") != -1
    tags:
      - filedeletion
      - 4.1.13
      - four
      - all


  - name: 4.1.13 - Ensure file deletion events by users are collected
    lineinfile:
      path: /etc/audit/rules.d/deletion.rules
      state: present
      line: "-a always,exit -F arch=b32 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete"
    when: 
     - filedeletion.stdout.find("FAILED") != -1
     - ansible_architecture != "x86_64"
    tags:
      - filedeletion
      - 4.1.13
      - four
      - all

  - name: 4.1.13 - Ensure file deletion events by users are collected
    lineinfile:
      path: /etc/audit/rules.d/deletion.rules
      state: present
      line: "{{item}}"
    with_items:
      - "-a always,exit -F arch=b64 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete"
      - "-a always,exit -F arch=b32 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete"
    when: 
     - filedeletion.stdout.find("FAILED") != -1
     - ansible_architecture == "x86_64"
    tags:
      - filedeletion
      - 4.1.13
      - four
      - all
  
  - name: 4.1.13 - Ensure file deletion events by users are collected
    command: service auditd restart
    failed_when: no
    when: filedeletion.stdout.find("FAILED") != -1
    tags:
      - filedeletion
      - 4.1.13
      - four
      - all
      
  - name:  4.1.14-Fetch the  sudoers value from ansible facts
    shell: echo "{{ ansible_local.sudoers_4114_audit }}" 
    register: sudoers
    ignore_errors: True
    tags:
      - sudoers
      - 4.1.14
      - four
      - all
  
  - name: 4.1.14 - Ensure changes to system administration scope (sudoers) is collected
    file: path=/etc/audit/rules.d/scope.rules state=touch owner=root group=root mode=0600
    when: sudoers.stdout.find("FAILED") != -1
    tags:
      - sudoers
      - 4.1.14
      - four
      - all
    
  - name: 4.1.14 - Ensure changes to system administration scope (sudoers) is collected
    lineinfile:
      path: /etc/audit/rules.d/scope.rules
      state: present
      line: "{{item}}"
    with_items:
      - "-w /etc/sudoers -p wa -k scope"
      - "-w /etc/sudoers.d/ -p wa -k scope"
    when: sudoers.stdout.find("FAILED") != -1
    tags:
      - sudoers
      - 4.1.14
      - four
      - all
    
  - name: 4.1.14 - Ensure changes to system administration scope (sudoers) is collected
    command: service auditd restart
    failed_when: no
    when: sudoers.stdout.find("FAILED") != -1
    tags:
      - sudoers
      - 4.1.14
      - four
      - all

  - name:  4.1.15-Fetch the  sudolog value from ansible facts
    shell: echo "{{ ansible_local.sudolog_4115_audit }}" 
    register: sudolog
    ignore_errors: True
    tags:
      - sudolog
      - 4.1.15
      - four
      - all
    
  - name: 4.1.15 - Ensure system administrator actions (sudolog) are collected
    file: path=/etc/audit/rules.d/actions.rules state=touch owner=root group=root mode=0600
    when: sudolog.stdout.find("FAILED") != -1
    tags:
      - sudolog
      - 4.1.15
      - four
      - all

  - name: 4.1.15 - Ensure system administrator actions (sudolog) are collected
    lineinfile:
      path: /etc/audit/rules.d/actions.rules
      state: present
      line: "-w /var/log/sudo.log -p wa -k actions"
    when: sudolog.stdout.find("FAILED") != -1
    tags:
      - sudolog
      - 4.1.15
      - four
      - all
    
  - name: 4.1.15 - Ensure system administrator actions (sudolog) are collected
    command: service auditd restart
    failed_when: no
    when: sudolog.stdout.find("FAILED") != -1
    tags:
      - sudolog
      - 4.1.15
      - four
      - all

  - name:  4.1.16-Fetch the kernelmodule  value from ansible facts
    shell: echo "{{ ansible_local.kernelmodule_4116_audit }}" 
    register: kernelmodule
    ignore_errors: True
    tags:
      - kernelmodule
      - 4.1.16
      - four
      - all

  - name:  4.1.16 - Ensure kernel module loading and unloading is collected
    file: path=/etc/audit/rules.d/modules.rules state=touch owner=root group=root mode=0600  
    when: kernelmodule.stdout.find("FAILED") != -1
    tags:
      - kernelmodule
      - 4.1.16
      - four
      - all
    
  - name: 4.1.16 - Ensure kernel module loading and unloading is collected
    lineinfile:
      path: /etc/audit/rules.d/modules.rules
      state: present
      line: "{{item}}"
    with_items:
      - "-w /sbin/insmod -p x -k modules"
      - "-w /sbin/rmmod -p x -k modules"
      - "-w /sbin/modprobe -p x -k modules"
      - "-a always,exit -F arch=b32 -S init_module -S delete_module -k modules"
    when: 
     - kernelmodule.stdout.find("FAILED") != -1
     - ansible_architecture != "x86_64"
    tags:
      - kernelmodule
      - 4.1.16
      - four
      - all
    
  - name: 4.1.16 - Ensure kernel module loading and unloading is collected
    lineinfile:
      path: /etc/audit/rules.d/modules.rules
      state: present
      line: "{{item}}"
    with_items:
      - "-w /sbin/insmod -p x -k modules"
      - "-w /sbin/rmmod -p x -k modules"
      - "-w /sbin/modprobe -p x -k modules"
      - "-a always,exit -F arch=b64 -S init_module -S delete_module -k modules"
    when: 
     - kernelmodule.stdout.find("FAILED") != -1
     - ansible_architecture == "x86_64"
    tags:
      - kernelmodule
      - 4.1.16
      - four
      - all
    
  - name: 4.1.16 - Ensure kernel module loading and unloading is collected
    command: service auditd restart
    failed_when: no
    when: kernelmodule.stdout.find("FAILED") != -1
    tags:
      - kernelmodule
      - 4.1.16
      - four
      - all      

  - name:  4.1.17-Fetch the auditconfig  value from ansible facts
    shell: echo "{{ ansible_local.auditconfig_4117_audit }}" 
    register: auditconfig
    ignore_errors: True
    tags:
      - auditconfig
      - 4.1.17
      - four
      - all   
 
  - name: 4.1.17 - Ensure the audit configuration is immutable
    file: path=/etc/audit/rules.d/99-finalize.rules state=touch owner=root group=root mode=0600
    when: auditconfig.stdout.find("FAILED") != -1
    tags:
      - auditconfig
      - 4.1.17
      - four
      - all
    
  - name: 4.1.17 - Ensure the audit configuration is immutable
    lineinfile:
      path:  /etc/audit/rules.d/99-finalize.rules
      state: present
      line: "-e 2"
    when: auditconfig.stdout.find("FAILED") != -1 
    tags:
      - auditconfig
      - 4.1.17
      - four
      - all
    
  - name: 4.1.17 - Ensure the audit configuration is immutable
    command: service auditd restart
    failed_when: no
    when: auditconfig.stdout.find("FAILED") != -1
    tags:
      - auditconfig
      - 4.1.17
      - four
      - all

  - name:  4.2.1.1-Fetch the  rsyslog value from ansible facts
    shell: echo "{{ ansible_local.rsyslog_4211_audit }}" 
    register: rsyslog
    ignore_errors: True
    tags:
      - rsyslog
      - 4.2.1.1
      - four
      - all
    
  - name: 4.2.1.1 - Ensure rsyslog is installed
    yum:
      name: rsyslog
      state: present
    failed_when: no
    when: rsyslog.stdout.find("FAILED") != -1
    tags:
      - rsyslog
      - 4.2.1.1
      - four
      - all

  - name:  4.2.1.2-Fetch the rsyslogenb  value from ansible facts
    shell: echo "{{ ansible_local.rsyslogenb_4212_audit }}" 
    register: rsyslogenb
    ignore_errors: True
    tags:
      - rsyslogenb
      - 4.2.1.2
      - four
      - all
    
  - name: 4.2.1.2 - Ensure rsyslog Service is enabled and running
    service:
      name: rsyslog
      enabled: yes
    when: rsyslogenb.stdout.find("FAILED") != -1
    tags:
      - rsyslogenb
      - 4.2.1.2
      - four
      - all

  - name:  4.2.1.3-Fetch the rsyslogperm  value from ansible facts
    shell: echo "{{ ansible_local.rsyslogperm_4213_audit }}" 
    register: rsyslogperm
    ignore_errors: True
    tags:
      - rsyslogperm
      - 4.2.1.3
      - four
      - all
    
  - name: 4.2.1.3 - Ensure rsyslog default file permissions configured
    lineinfile:
      path: /etc/rsyslog.conf
      state: present
      regexp: "^$FileCreateMode*"
      line: "$FileCreateMode 0640"
    when: rsyslogperm.stdout.find("FAILED") != -1
    failed_when: no
    tags:
      - rsyslogperm
      - 4.2.1.3
      - four
      - all

  - name:  4.2.1.4-Fetch the rloggingconf  value from ansible facts
    shell: echo "{{ ansible_local.rloggingconf_4214_audit }}" 
    register: rloggingconf
    ignore_errors: True
    tags:
      - rloggingconf
      - 4.2.1.4
      - four
      - all
    
  - name: 4.2.1.4 - Ensure logging is configured
    lineinfile:
      path: /etc/rsyslog.conf
      state: present
      line: "{{item}}"
    with_items:
      - "*.emerg :omusrmsg:*"
      - "auth,authpriv.* /var/log/secure"
      - "mail.* -/var/log/mail"
      - "mail.info -/var/log/mail.info"
      - "mail.warning -/var/log/mail.warn"
      - "mail.err /var/log/mail.err"
      - "news.crit -/var/log/news/news.crit"
      - "news.err -/var/log/news/news.err"
      - "news.notice -/var/log/news/news.notice"
      - "*.=warning;*.=err -/var/log/warn"
      - "*.crit /var/log/warn"
      - "*.*;mail.none;news.none -/var/log/messages"
      - "local0,local1.* -/var/log/localmessages"
      - "local2,local3.* -/var/log/localmessages"
      - "local4,local5.* -/var/log/localmessages"
      - "local6,local7.* -/var/log/localmessages"
    when: rloggingconf.stdout.find("FAILED") != -1
    failed_when: no
    tags:
      - rloggingconf
      - 4.2.1.4
      - four
      - all
 
  - name: 4.2.1.4 - Ensure logging is configured
    service: 
      name: rsyslog
      state: restart
    failed_when: no
    when: rloggingconf.stdout.find("FAILED") != -1
    tags:
      - rloggingconf
      - 4.2.1.4
      - four
      - all

  - name:  4.2.1.5-Fetch the  rsyslogsendlogs value from ansible facts
    shell: echo "{{ ansible_local.rsyslogsendlogs_4215_audit }}" 
    register: rsyslogsendlogs
    ignore_errors: True
    tags:
      - rsyslogsendlogs
      - 4.2.1.5
      - four
      - all
    
  - name: 4.2.1.5 - Ensure rsyslog is configured to send logs to a remote log host
    lineinfile:
      path: /etc/rsyslog.conf
      state: present
      line: "*.* @@loghost.example.com"
    when: rsyslogsendlogs.stdout.find("FAILED") != -1
    tags:
      - rsyslogsendlogs
      - 4.2.1.5
      - four
      - all
         
  - name: 4.2.1.5 - Ensure rsyslog is configured to send logs to a remote log host
    service: 
      name: rsyslog
      state: restart
    failed_when: no
    when: rsyslogsendlogs.stdout.find("FAILED") != -1
    tags:
      - rsyslogsendlogs
      - 4.2.1.5
      - four
      - all

  - name:  4.2.1.6-Fetch the remotesyslogmsg  value from ansible facts
    shell: echo "{{ ansible_local.remotesyslogmsg_4216_audit }}" 
    register: remotesyslogmsg
    ignore_errors: True
    tags:
      - remotesyslogmsg
      - 4.2.1.6
      - four
      - all
    
  - name: 4.2.1.6 - Ensure remote rsyslog messages are only accepted on designated log hosts
    lineinfile:
      path: /etc/rsyslog.conf
      state: present
      regexp: "^$ModLoad imtcp"
      line: "$ModLoad imtcp"
    when: remotesyslogmsg.stdout.find("FAILED") != -1
    tags:
      - remotesyslogmsg
      - 4.2.1.6
      - four
      - all
   
  - name: 4.2.1.6 - Ensure remote rsyslog messages are only accepted on designated log hosts
    lineinfile:
      path: /etc/rsyslog.conf
      state: present
      regexp: "^$InputTCPServerRun 514"
      line: "$InputTCPServerRun 514"
    when: remotesyslogmsg.stdout.find("FAILED") != -1
    tags:
      - remotesyslogmsg
      - 4.2.1.6
      - four
      - all
    
  - name: 4.2.1.6 - Ensure remote rsyslog messages are only accepted on designated log hosts
    service: 
      name: rsyslog
      state: reloaded
    failed_when: no
    when: rsyslogsendlogs.stdout.find("FAILED") != -1
    tags:
      - remotesyslogmsg
      - 4.2.1.6
      - four
      - all

  - name:  4.2.2.1-Fetch the  journalsendlogs value from ansible facts
    shell: echo "{{ ansible_local.journalsendlogs_4221_audit }}" 
    register: journalsendlogs
    ignore_errors: True
    tags:
      - journalsendlogs
      - 4.2.2.1
      - four
      - all
    
  - name: 4.2.2.1 - Ensure journald is configured to send logs to rsyslog
    lineinfile:
      path: /etc/systemd/journald.conf
      state: present
      regexp: "^(ForwardToSyslog =*|#ForwardToSyslog =*)"
      line: "ForwardToSyslog=yes"
    when: journalsendlogs.stdout.find("FAILED") != -1
    tags:
      - journalsendlogs
      - 4.2.2.1
      - four
      - all

  - name:  4.2.2.2-Fetch the journalcompresslog  value from ansible facts
    shell: echo "{{ ansible_local.journalcompresslog_4222_audit }}" 
    register: journalcompresslog
    ignore_errors: True
    tags:
      - journalcompresslog
      - 4.2.2.2
      - four
      - all
      
  - name: 4.2.2.2 - Ensure journald is configured to compress large log files
    lineinfile:
      path: /etc/systemd/journald.conf
      state: present
      regexp: "^Compress =*"
      line: "Compress=yes"
    when: journalcompresslog.stdout.find("FAILED") != -1
    tags:
      - journalcompresslog
      - 4.2.2.2
      - four
      - all

  - name:  4.2.2.3-Fetch the  journalpersisdisk value from ansible facts
    shell: echo "{{ ansible_local.journalpersisdisk_4223_audit }}" 
    register: journalpersisdisk
    ignore_errors: True
    tags:
      - journalpersisdisk
      - 4.2.2.3
      - four
      - all
    
  - name: 4.2.2.3 - Ensure journald is configured to write logfiles to persistent disk
    lineinfile:
      path: /etc/systemd/journald.conf
      state: present
      regexp: "^Storage =*"
      line: "Storage=persistent"
    when: journalpersisdisk.stdout.find("FAILED") != -1
    tags:
      - journalpersisdisk
      - 4.2.2.3
      - four
      - all

  - name:  4.2.3-Fetch the  permlogfiles value from ansible facts
    shell: echo "{{ ansible_local.permlogfiles_423_audit }}" 
    register: permlogfiles
    ignore_errors: True
    tags:
      - permlogfiles
      - 4.2.3
      - four
      - all
      
  - name: 4.2.3 - Ensure permissions on all logfiles are configured
    shell: 'find /var/log -type f -exec chmod g-wx,o-rwx "{}" + -o -type d -exec chmod g-wx,o-rwx "{}" +'
    when: permlogfiles.stdout.find("FAILED") != -1
    tags:
      - permlogfiles
      - 4.2.3
      - four
      - all
      
  - name:  4.2.4-Fetch the logrotate  value from ansible facts
    shell: echo "{{ ansible_local.logrotate_424_audit }}" 
    register: logrotate
    ignore_errors: True
    tags:
      - logrotate
      - 4.2.4
      - four
      - all
    
  - name: 4.2.4 - Ensure logrotate is configured
    lineinfile:
      path: /etc/logrotate.conf
      state: present
      regexp: "^maxage*"
      line: "maxage 90"
    when: logrotate.stdout.find("FAILED") != -1
    tags:
      - logrotate
      - 4.2.4
      - four
      - all

  - name:  5.1.1-Fetch the cron  value from ansible facts
    shell: echo "{{ ansible_local.cron_511_audit }}"
    register: cron
    ignore_errors: True
    tags:
      - cron
      - 5.1.1
      - five
      - all
      
  - name: 5.1.1 - Ensure cron daemon is enabled and running
    service:
      name: crond
      enabled: yes
    when: cron.stdout.find("FAILED") != -1
    tags:
      - cron
      - 5.1.1
      - five
      - all

  - name:  5.1.2-Fetch the  permcrontab value from ansible facts
    shell: echo "{{ ansible_local.permcrontab_512_audit }}"
    register: permcrontab
    ignore_errors: True
    tags:
      - permcrontab
      - 5.1.2
      - five
      - all    
 
  - name: 5.1.2 - Ensure permissions on /etc/crontab are configured
    file:
      path: "/etc/crontab"
      state: touch
      mode: 0600
      owner: root
      group: root
    when: permcrontab.stdout.find("FAILED") != -1 
    tags:
      - permcrontab
      - 5.1.2
      - five
      - all

  - name:  5.1.3-Fetch the  permcronhourly value from ansible facts
    shell: echo "{{ ansible_local.permcronhourly_513_audit }}"
    register: permcronhourly
    ignore_errors: True
    tags:
      - permcronhourly
      - 5.1.3
      - five
      - all    

  - name: 5.1.3 - Ensure permissions on /etc/cron.hourly are configured
    file:
      path: "/etc/cron.hourly"
      state: touch
      mode: 0700
      owner: root
      group: root
    when: permcronhourly.stdout.find("FAILED") != -1   
    tags:
      - permcronhourly
      - 5.1.3
      - five
      - all

  - name:  5.1.4-Fetch the permcrondaily  value from ansible facts
    shell: echo "{{ ansible_local.permcrondaily_514_audit }}"
    register: permcrondaily
    ignore_errors: True
    tags:
      - permcrondaily
      - 5.1.4
      - five
      - all
      
  - name: 5.1.4 Ensure permissions on /etc/cron.daily are configured
    file:
      path: "/etc/cron.daily"
      state: touch
      mode: 0700
      owner: root
      group: root
    when: permcrondaily.stdout.find("FAILED") != -1     
    tags:
      - permcrondaily
      - 5.1.4
      - five
      - all

  - name:  5.1.5-Fetch the permcronweekly  value from ansible facts
    shell: echo "{{ ansible_local.permcronweekly_515_audit }}"
    register: permcronweekly
    ignore_errors: True
    tags:
      - permcronweekly
      - 5.1.5
      - five
      - all
      
  - name: 5.1.5 - Ensure permissions on /etc/cron.weekly are configured
    file:
      path: "/etc/cron.weekly"
      state: touch
      mode: 0700
      owner: root
      group: root
    when: permcronweekly.stdout.find("FAILED") != -1  
    tags:
      - permcronweekly
      - 5.1.5
      - five
      - all
      
  - name:  5.1.6-Fetch the permcronmonthly  value from ansible facts
    shell: echo "{{ ansible_local.permcronmonthly_516_audit }}"
    register: permcronmonthly
    ignore_errors: True
    tags:
      - permcronmonthly
      - 5.1.6
      - five
      - all
      
  - name: 5.1.6 - Ensure permissions on /etc/cron.monthly are configured
    file:
      path: "/etc/cron.monthly"
      state: touch
      mode: 0700
      owner: root
      group: root
    when: permcronmonthly.stdout.find("FAILED") != -1   
    tags:
      - permcronmonthly
      - 5.1.6
      - five
      - all
      
  - name:  5.1.7-Fetch the  permcrond value from ansible facts
    shell: echo "{{ ansible_local.permcrond_517_audit }}"
    register: permcrond
    ignore_errors: True
    tags:
      - permcrond
      - 5.1.7
      - five
      - all
      
  - name: 5.1.7 Ensure permissions on /etc/cron.d are configured
    file:
      path: "/etc/cron.d"
      state: touch
      mode: 0700
      owner: root
      group: root
    when: permcrond.stdout.find("FAILED") != -1   
    tags:
      - permcrond
      - 5.1.7
      - five
      - all

  - name:  5.1.8-Fetch the   value from ansible facts
    shell: echo "{{ ansible_local.cronuser_518_audit }}"
    register: cronuser
    ignore_errors: True
    tags:
      - cronuser
      - 5.1.8
      - five
      - all
      
  - name: 5.1.8 - Ensure cron is restricted to authorized users 
    file:
      path: "/etc/cron.deny"
      state: absent
    when: cronuser.stdout.find("FAILED") != -1    
    tags:
      - cronuser
      - 5.1.8
      - five
      - all

  - name: 5.1.8 - Ensure cron is restricted to authorized users
    file:
      path: "/etc/cron.allow"
      state: touch
      mode: 0600
      owner: root
      group: root
    when: cronuser.stdout.find("FAILED") != -1    
    tags:
      - cronuser
      - 5.1.8
      - five
      - all

  - name:  5.1.9-Fetch the  atcron value from ansible facts
    shell: echo "{{ ansible_local.atcron_519_audit }}"
    register: atcron
    ignore_errors: True
    tags:
      - atcron
      - 5.1.9
      - five
      - all
      
  - name: 5.1.9 - Ensure at/cron is restricted to authorized users
    file:
      path: "/etc/at.deny"
      state: absent
    when: atcron.stdout.find("FAILED") != -1    
    tags:
      - atcron
      - 5.1.9
      - five
      - all

  - name: 5.1.9 - Ensure at/cron is restricted to authorized users
    file:
      path: "/etc/at.allow"
      state: touch
      mode: 0600
      owner: root
      group: root
    when: atcron.stdout.find("FAILED") != -1    
    tags:
      - atcron
      - 5.1.9
      - five
      - all

  - name:  5.2.1-Fetch the sshdperm  value from ansible facts
    shell: echo "{{ ansible_local.sshdperm_521_audit }}"
    register: sshdperm
    ignore_errors: True
    tags:
      - sshdperm
      - 5.2.1
      - five
      - all    

  - name: 5.2.1 - Ensure permissions on /etc/ssh/sshd_config are configured
    file:
      path: "/etc/ssh/sshd_config"
      state: touch
      mode: 0600
      owner: root
      group: root
    when: sshdperm.stdout.find("FAILED") != -1     
    tags:
      - sshdperm
      - 5.2.1
      - five
      - all

  - name:  5.2.2-Fetch the  sshpermpvtkey value from ansible facts
    shell: echo "{{ ansible_local.sshpermpvtkey_522_audit }}"
    register: sshpermpvtkey
    ignore_errors: True
    tags:
      - sshpermpvtkey
      - 5.2.2
      - five
      - all 
  
  - name: 5.2.2 - Ensure permissions on SSH private host key files are configured
    command: "{{item}}"
    with_items:
      - find /etc/ssh -xdev -type f -name 'ssh_host_*_key' -exec chown root:ssh_keys {} \;
      - find /etc/ssh -xdev -type f -name 'ssh_host_*_key' -exec chmod u-x,g-wx,o-rwx {} \;
    failed_when: no
    when: sshpermpvtkey.stdout.find("FAILED") != -1
    tags:
      - sshpermpvtkey
      - 5.2.2
      - five 
      - all
  
  - name:  5.2.3-Fetch the sshpermpubkey  value from ansible facts
    shell: echo "{{ ansible_local.sshpermpubkey_523_audit }}"
    register: sshpermpubkey
    ignore_errors: True
    tags:
      - sshpermpubkey
      - 5.2.3
      - five
      - all 
  
  - name: 5.2.3 - Ensure permissions on SSH public host key files are configured
    command: "{{item}}"
    with_items:
      - find /etc/ssh -xdev -type f -name 'ssh_host_*_key.pub' -exec chown root:root {} \;
      - find /etc/ssh -xdev -type f -name 'ssh_host_*_key.pub' -exec chmod u-x,go-wx {} \;
    failed_when: no
    when: sshpermpubkey.stdout.find("FAILED") != -1
    tags:
      - sshpermpubkey
      - 5.2.3
      - five
      - all

  - name:  5.2.4-Fetch the  sshaccess value from ansible facts
    shell: echo "{{ ansible_local.sshaccess_524_audit }}"
    register: sshaccess
    ignore_errors: True
    tags:
      - sshaccess
      - 5.2.4
      - five
      - all
    
  - name: 5.2.4 - Ensure SSH access is limited 
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      line: "AllowUsers #<userlist>"
    failed_when: no
    when: sshaccess.stdout.find("FAILED") != -1
    tags:
      - sshaccess
      - 5.2.4
      - five
      - all

  - name: 5.2.4 - Ensure SSH access is limited
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      line: "AllowGroups #<grouplist>"
    failed_when: no
    when: sshaccess.stdout.find("FAILED") != -1
    tags:
      - sshaccess
      - 5.2.4
      - five
      - all

  - name: 5.2.4 - Ensure SSH access is limited
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      line: "DenyUsers #<userlist>"
    failed_when: no
    when: sshaccess.stdout.find("FAILED") != -1
    tags:
      - sshaccess
      - 5.2.4
      - five
      - all

  - name: 5.2.4 - Ensure SSH access is limited
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      line: "DenyGroups #<grouplist>"
    failed_when: no
    when: sshaccess.stdout.find("FAILED") != -1
    tags:
      - sshaccess
      - 5.2.4
      - five
      - all

  - name:  5.2.5-Fetch the sshloglevel  value from ansible facts
    shell: echo "{{ ansible_local.sshloglevel_525_audit }}"
    register: sshloglevel
    ignore_errors: True
    tags:
      - sshloglevel
      - 5.2.5
      - five
      - all
      
  - name: 5.2.5 - Ensure SSH LogLevel is appropriate
    lineinfile:
      path: /etc/ssh/sshd_config 
      state: present
      regexp: "^(LogLevel*|#LogLevel*)"
      line: "LogLevel INFO"
    when: sshloglevel.stdout.find("FAILED") != -1  
    tags:
      - sshloglevel
      - 5.2.5
      - five
      - all

  - name:  5.2.6-Fetch the sshx11forward  value from ansible facts
    shell: echo "{{ ansible_local.sshx11forward_526_audit }}"
    register: sshx11forward
    ignore_errors: True
    tags:
      - sshx11forward
      - 5.2.6
      - five
      - all
  
  - name: 5.2.6 - Ensure SSH X11 forwarding is disabled
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(X11Forwarding*|#X11Forwarding*)"
      line: "X11Forwarding no"
    when: sshx11forward.stdout.find("FAILED") != -1
    tags:
      - sshx11forward
      - 5.2.6
      - five
      - all

  - name:  5.2.7-Fetch the sshmaxauthtries  value from ansible facts
    shell: echo "{{ ansible_local.sshmaxauthtries_527_audit }}"
    register: sshmaxauthtries
    ignore_errors: True
    tags:
      - sshmaxauthtries
      - 5.2.7
      - five
      - all
  
  - name: 5.2.7 - Ensure SSH MaxAuthTries is set to 4 or less
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(MaxAuthTries*|#MaxAuthTries*)"
      line: "{{ MaxAuthTries }}"
    when: sshmaxauthtries.stdout.find("FAILED") != -1
    tags:
      - sshmaxauthtries
      - 5.2.7
      - five
      - all

  - name:  5.2.8-Fetch the  sshignorerhosts value from ansible facts
    shell: echo "{{ ansible_local.sshignorerhosts_528_audit }}"
    register: sshignorerhosts
    ignore_errors: True
    tags:
      - sshignorerhosts
      - 5.2.8
      - five
      - all
  
  - name: 5.2.8 - Ensure SSH IgnoreRhosts is enabled
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(IgnoreRhosts*|#IgnoreRhosts*)"
      line: "{{ IgnoreRhosts }}"
    failed_when: no
    when: sshignorerhosts.stdout.find("FAILED") != -1
    tags:
      - sshignorerhosts
      - 5.2.8
      - five
      - all
 
  - name:  5.2.9-Fetch the  sshauthentication value from ansible facts
    shell: echo "{{ ansible_local.sshauthentication_529_audit }}"
    register: sshauthentication
    ignore_errors: True
    tags:
      - sshauthentication
      - 5.2.9
      - five
      - all
  
  - name: 5.2.9 - Ensure SSH HostbasedAuthentication is disabled 
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(HostbasedAuthentication*|#HostbasedAuthentication*)"
      line: "HostbasedAuthentication no"
    failed_when: no
    when: sshauthentication.stdout.find("FAILED") != -1
    tags:
      - sshauthentication
      - 5.2.9
      - five
      - all

  - name:  5.2.10-Fetch the sshrootlogin  value from ansible facts
    shell: echo "{{ ansible_local.sshrootlogin_5210_audit }}"
    register: sshrootlogin
    ignore_errors: True
    tags:
      - sshrootlogin
      - 5.2.10
      - five
      - all 

  - name: 5.2.10 - Ensure SSH root login is disabled
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(PermitRootLogin*|#PermitRootLogin*)"
      line: "{{ PermitRootLogin }}"
    when: sshrootlogin.stdout.find("FAILED") != -1
    tags:
      - sshrootlogin
      - 5.2.10
      - five
      - all

  - name:  5.2.11-Fetch the sshpep  value from ansible facts
    shell: echo "{{ ansible_local.sshpep_5211_audit }}"
    register: sshpep
    ignore_errors: True
    tags:
      - sshpep
      - 5.2.11
      - five
      - all
  
  - name: 5.2.11 - Ensure SSH PermitEmptyPasswords is disabled
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(PermitEmptyPasswords*|#PermitEmptyPasswords*)"
      line: "PermitEmptyPasswords no"
    failed_when: no
    when: sshpep.stdout.find("FAILED") != -1
    tags:
      - sshpep
      - 5.2.11
      - five
      - all

  - name: 5.2.12-Fetch the sshpue  value from ansible facts
    shell: echo "{{ ansible_local.sshpue_5212_audit }}"
    register: sshpue
    ignore_errors: True
    tags:
      - sshpue
      - 5.2.12
      - five
      - all
  
  - name: 5.2.12 - Ensure SSH PermitUserEnvironment is disabled
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(PermitUserEnvironment*|#PermitUserEnvironment*)"
      line: "PermitUserEnvironment no"
    failed_when: no
    when: sshpue.stdout.find("FAILED") != -1
    tags:
      - sshpue
      - 5.2.12
      - five
      - all

  - name:  5.2.13-Fetch the  sshchipers value from ansible facts
    shell: echo "{{ ansible_local.sshchipers_5213_audit }}"
    register: sshchipers
    ignore_errors: True
    tags:
      - sshchipers
      - 5.2.13
      - five
      - all
    
  - name: 5.2.13 - Ensure only strong Ciphers are used 
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(Ciphers*|#Ciphers*)"
      line: "Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr"
    failed_when: no
    when: sshchipers.stdout.find("FAILED") != -1
    tags:
      - sshchipers
      - 5.2.13
      - five
      - all

  - name:  5.2.14-Fetch the sshmacalgorithm  value from ansible facts
    shell: echo "{{ ansible_local.sshmacalgorithm_5214_audit }}"
    register: sshmacalgorithm
    ignore_errors: True
    tags:
      - sshmacalgorithm
      - 5.2.14
      - five
      - all
  
  - name: 5.2.14 - Ensure only strong MAC algorithms are used 
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      line: "MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512,hmac-sha2-256"
    when: sshmacalgorithm.stdout.find("FAILED") != -1
    tags:
      - sshmacalgorithm
      - 5.2.14
      - five
      - all

  - name:  5.2.15-Fetch the sshkeyexalgorithm  value from ansible facts
    shell: echo "{{ ansible_local.sshkeyexalgorithm_5215_audit }}"
    register: sshkeyexalgorithm
    ignore_errors: True
    tags:
      - sshkeyexalgorithm
      - 5.2.15
      - five
      - all
    
  - name: 5.2.15 - Ensure only strong Key Exchange algorithms are used
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      line: "KexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,ecdh-sha2-nistp521,ecdh-sha2-nistp384,ecdh-sha2-nistp256"
    failed_when: no
    when: sshkeyexalgorithm.stdout.find("FAILED") != -1
    tags:
      - sshkeyexalgorithm
      - 5.2.15
      - five
      - all

  - name:  5.2.16-Fetch the sshidletimeout  value from ansible facts
    shell: echo "{{ ansible_local.sshidletimeout_5216_audit }}"
    register: sshidletimeout
    ignore_errors: True
    tags:
      - sshidletimeout
      - 5.2.16
      - five
      - all
  
  - name: 5.2.16 - Ensure SSH Idle Timeout Interval is configured 
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(ClientAliveInterval*|#ClientAliveInterval*)"
      line: "{{ ClientAliveInterval }}"
    failed_when: no
    when: sshidletimeout.stdout.find("FAILED") != -1
    tags:
      - sshidletimeout
      - 5.2.16
      - five
      - all
 
  - name: 5.2.16 - Ensure SSH Idle Timeout Interval is configured
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(ClientAliveCountMax*|#ClientAliveCountMax*)"
      line: "{{ ClientAliveCountMax }}"
    failed_when: no
    when: sshidletimeout.stdout.find("FAILED") != -1
    tags:
      - sshidletimeout
      - 5.2.16
      - five
      - all

  - name:  5.2.17-Fetch the sshlogingracetime  value from ansible facts
    shell: echo "{{ ansible_local.sshlogingracetime_5217_audit }}"
    register: sshlogingracetime
    ignore_errors: True
    tags:
      - sshlogingracetime
      - 5.2.17
      - five
      - all
    
  - name: 5.2.17 - Ensure SSH LoginGraceTime is set to one minute or less
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(LoginGraceTime*|#LoginGraceTime*)"
      line: "LoginGraceTime 60"
    when: sshlogingracetime.stdout.find("FAILED") != -1
    tags:
      - sshlogingracetime
      - 5.2.17
      - five
      - all

  - name:  5.2.18-Fetch the sshwarningbanner  value from ansible facts
    shell: echo "{{ ansible_local.sshwarningbanner_5218_audit }}"
    register: sshwarningbanner
    ignore_errors: True
    tags:
      - sshwarningbanner
      - 5.2.18
      - five
      - all
  
  - name: 5.2.18 - Ensure SSH warning banner is configured
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(Banner*|#Banner*)"
      line: "Banner /etc/issue.net"
    when: sshwarningbanner.stdout.find("FAILED") != -1
    tags:
      - sshwarningbanner
      - 5.2.18
      - five
      - all

  - name:  5.2.19-Fetch the sshpam  value from ansible facts
    shell: echo "{{ ansible_local.sshpam_5219_audit }}"
    register: sshpam
    ignore_errors: True
    tags:
      - sshpam
      - 5.2.19
      - five
      - all
  
  - name: 5.2.19 - Ensure SSH PAM is enabled
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(UsePAM*|#UsePAM*)"
      line: "UsePAM yes"
    failed_when: no
    when: sshpam.stdout.find("FAILED") != -1
    tags:
      - sshpam
      - 5.2.19
      - five
      - all

  - name:  5.2.20-Fetch the sshtcpforward  value from ansible facts
    shell: echo "{{ ansible_local.sshtcpforward_5220_audit }}"
    register: sshtcpforward
    ignore_errors: True
    tags:
      - sshtcpforward
      - 5.2.20
      - five
      - all
  
  - name: 5.2.20 - Ensure SSH AllowTcpForwarding is disabled
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(AllowTcpForwarding*|#AllowTcpForwarding*)"
      line: "AllowTcpForwarding no"
    failed_when: no
    when: sshtcpforward.stdout.find("FAILED") != -1
    tags:
      - sshtcpforward
      - 5.2.20
      - five
      - all

  - name:  5.2.21-Fetch the  sshmaxstartups value from ansible facts
    shell: echo "{{ ansible_local.sshmaxstartups_5221_audit }}"
    register: sshmaxstartups
    ignore_errors: True
    tags:
      - sshmaxstartups
      - 5.2.21
      - five
      - all
  
  - name: 5.2.21 - Ensure SSH MaxStartups is configured
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(MaxStartups*|#MaxStartups*)"
      line: "MaxStartups 10:30:60"
    failed_when: no
    when: sshmaxstartups.stdout.find("FAILED") != -1
    tags:
      - sshmaxstartups
      - 5.2.21
      - five
      - all

  - name:  5.2.22-Fetch the sshmaxsessions  value from ansible facts
    shell: echo "{{ ansible_local.sshmaxsessions_5222_audit }}"
    register: sshmaxsessions
    ignore_errors: True
    tags:
      - sshmaxsessions
      - 5.2.22
      - five
      - all
    
  - name: 5.2.22 - Ensure SSH MaxSessions is limited
    lineinfile:
      path: /etc/ssh/sshd_config
      state: present
      regexp: "^(MaxSessions*|#MaxSessions*)"
      line: "MaxSessions 10"
    failed_when: no
    when: sshmaxsessions.stdout.find("FAILED") != -1
    tags:
      - sshmaxsessions
      - 5.2.22
      - five
      - all

  - name:  5.3.1-Fetch the passwdcreation  value from ansible facts
    shell: echo "{{ ansible_local.passwdcreation_531_audit }}"
    register: passwdcreation
    ignore_errors: True
    tags:
      - passwdcreation
      - 5.3.1
      - five
      - all

  - name: 5.3.1 - Ensure password creation requirements are configured
    lineinfile:
      path: /etc/security/pwquality.conf
      state: present
      regexp: "^(minlen*|# minlen*)"
      line: "minlen = 14"
    when: passwdcreation.stdout.find("FAILED") != -1  
    tags:
      - passwdcreation
      - 5.3.1
      - five
      - all

  - name: 5.3.1 - Ensure password creation requirements are configured
    lineinfile:
      path: /etc/security/pwquality.conf
      state: present
      regexp: "^(minclass*|# minclass*)"
      line: "minclass = 4"
    when: passwdcreation.stdout.find("FAILED") != -1  
    tags:
      - passwdcreation
      - 5.3.1
      - five
      - all

  - name:  5.3.2-Fetch the lockout  value from ansible facts 
    shell: echo "{{ ansible_local.lockout_532_audit }}"
    register: lockout
    ignore_errors: True
    tags:
      - lockout
      - 5.3.2
      - five
      - all
      
  - name: 5.3.2 - Ensure lockout for failed password attempts is configured
    lineinfile:
      path: "{{item.path}}"
      state: present
      insertafter: "{{item.insertafter}}"
      line: "{{item.line}}"
    with_items:
      - { path: '/etc/pam.d/password-auth', insertafter: "^(auth.*required.*pam_env.so.*)", line: 'auth   required   pam_faillock.so preauth silent audit deny=5 unlock_time=90' }
      - { path: '/etc/pam.d/system-auth', insertafter: "^(auth.*required.*pam_env.so.*)", line: 'auth   required   pam_faillock.so preauth silent audit deny=5 unlock_time=90' }
    when: lockout.stdout.find("FAILED") != -1  
    tags:
      - lockout
      - 5.3.2
      - five
      - all

  - name: 5.3.2 - Ensure lockout for failed password attempts is configured
    lineinfile:
      path: "{{item.path}}"
      state: present
      insertbefore: "{{item.insertbefore}}"
      line: "{{item.line}}"
    with_items:
      - { path: '/etc/pam.d/password-auth', insertbefore: "^(auth.*requisite.*pam_succeed_if.so.*)", line: 'auth [default=die] pam_faillock.so authfail audit deny=5
unlock_time=900' }
      - { path: '/etc/pam.d/system-auth', insertbefore: "^(auth.*requisite.*pam_succeed_if.so.*)", line: 'auth [default=die] pam_faillock.so authfail audit deny=5
unlock_time=900' }
      - { path: '/etc/pam.d/password-auth', insertbefore: "^(account.*required.*pam_unix.so.*)", line: 'account   required   pam_faillock.so' }
      - { path: '/etc/pam.d/system-auth', insertbefore: "^(account.*required.*pam_unix.so.*)", line: 'account   required   pam_faillock.so' }
    when: lockout.stdout.find("FAILED") != -1  
    tags:
      - lockout
      - 5.3.2
      - five
      - all

  - name:  5.3.3-Fetch the passwdhashing  value from ansible facts
    shell: echo "{{ ansible_local.passwdhashing_533_audit }}"
    register: passwdhashing
    ignore_errors: True
    tags:
      - passwdhashing
      - 5.3.3
      - five
      - all 
      
  - name: 5.3.3 - Ensure password hashing algorithm is SHA-512
#    command: sed -i 's/pam_unix.so.*/& sha512/' /etc/pam.d/password-auth
    lineinfile:
      path: /etc/pam.d/password-auth
      state: present
      regexp: '^(password.*sufficient.*pam_unix.so.*)$'
      line: '\1 sha512'
      backrefs: yes
    when: passwdhashing.stdout.find("FAILED") != -1
    tags:
      - passwdhashing
      - 5.3.3
      - five
      - all

  - name: 5.3.3 - Ensure password hashing algorithm is SHA-512
    lineinfile:
      path: /etc/pam.d/system-auth
      state: present
      regexp: '^(password.*sufficient.*pam_unix.so.*)$'
      line: '\1 sha512'
      backrefs: yes
    when: passwdhashing.stdout.find("FAILED") != -1
    tags:
      - passwdhashing
      - 5.3.3
      - five
      - all

  - name:  5.3.4-Fetch the passwdreuse  value from ansible facts
    shell: echo "{{ ansible_local.passwdreuse_534_audit }}"
    register: passwdreuse
    ignore_errors: True
    tags:
      - passwdreuse
      - 5.3.4
      - five
      - all

  - name: 5.3.4 - Ensure password reuse is limited
#    command: sed -i 's/pam_unix.so.*/& remember=5/' /etc/pam.d/password-auth
    lineinfile:
      path: /etc/pam.d/password-auth
      state: present
      regexp: '^(password.*sufficient.*pam_unix.so.*)$'
      line: '\1 remember=5'
      backrefs: yes
    when: passwdreuse.stdout.find("FAILED") != -1
    tags:
      - passwdreuse
      - 5.3.4
      - five
      - all

  - name: 5.3.4 - Ensure password reuse is limited
#    command: sed -i 's/pam_unix.so.*/& remember=5/' /etc/pam.d/system-auth   #audit  [grep ^password.*sufficient.*pam_unix.so /etc/pam.d/system-auth | grep -o remember=5]
    lineinfile:
      path: /etc/pam.d/system-auth
      state: present
      regexp: '^(password.*sufficient.*pam_unix.so.*)$'
      line: '\1 remember=5'
      backrefs: yes
    when: passwdreuse.stdout.find("FAILED") != -1
    tags:
      - passwdreuse
      - 5.3.4
      - five
      - all

  - name:  5.4.1.1-Fetch the passwdexpiration  value from ansible facts
    shell: echo "{{ ansible_local.passwdexpiration_5411_audit }}"
    register: passwdexpiration
    ignore_errors: True
    tags:
      - passwdexpiration
      - 5.4.1.1
      - five
      - all
      
  - name: 5.4.1.1 - Ensure password expiration is 365 days or less
    lineinfile:
      path: /etc/login.defs
      state: present
      regexp: "^(PASS_MAX_DAYS.*)"
      line: "{{ PASS_MAX_DAYS }}"
    when: passwdexpiration.stdout.find("FAILED") != -1   
    tags:
      - passwdexpiration
      - 5.4.1.1
      - five
      - all

  - name: 5.4.1.1 - Ensure password expiration is 365 days or less
    shell: "grep ':$6' /etc/shadow | cut -d: -f1,5 | awk -F: '$2>=365 {print $1}'"
    register: echo
    when: passwdexpiration.stdout.find("FAILED") != -1 
    tags:
      - passwdexpiration
      - 5.4.1.1
      - five
      - all
  
  - name: 5.4.1.1 - Ensure password expiration is 365 days or less
    chage: user="{{ item }}" sp_max=365
    loop: "{{ echo.stdout_lines }}"
    when:     
      - passwdexpiration.stdout.find("FAILED") != -1 
      - item != "root"    
    tags:
      - passwdexpiration
      - 5.4.1.1
      - five
      - all

  - name:  5.4.1.2-Fetch the minidays  value from ansible facts 
    shell: echo "{{ ansible_local.minidays_5412_audit }}"
    register: minidays
    ignore_errors: True
    tags:
      - minidays
      - 5.4.1.2
      - five
      - all
      
  - name: 5.4.1.2 - Ensure minimum days between password changes is configured  
    lineinfile:
      path: /etc/login.defs
      state: present
      regexp: "^(PASS_MIN_DAYS.*)"
      line: "{{ PASS_MIN_DAYS }}"
    when: minidays.stdout.find("FAILED") != -1
    tags:
      - minidays
      - 5.4.1.2
      - five
      - all

  - name: 5.4.1.2 - Ensure minimum days between password changes is configured 
    shell: "grep ':$6' /etc/shadow | awk -F: '$6>=7 {print $1}'"
    register: echo
    when: minidays.stdout.find("FAILED") != -1
    tags:
      - minidays
      - 5.4.1.2
      - five
      - all

  - name: 5.4.1.2 - Ensure minimum days between password changes is configured 
    chage: user="{{ item }}" sp_min=7
    loop: "{{ echo.stdout_lines }}"
    when: 
      - minidays.stdout.find("FAILED") != -1
      - item != "root"
    tags:
      - minidays
      - 5.4.1.2
      - five
      - all

  - name:  5.4.1.3-Fetch the warningdays  value from ansible facts
    shell: echo "{{ ansible_local.warningdays_5413_audit }}"
    register: warningdays
    ignore_errors: True
    tags:
      - warningdays
      - 5.4.1.3
      - five
      - all
      
  - name: 5.4.1.3 - Ensure password expiration warning days is 7 or more
    lineinfile:
      path: /etc/login.defs
      state: present
      regexp: "^(PASS_WARN_AGE.*)"
      line: "{{ PASS_WARN_AGE }}"
    when: warningdays.stdout.find("FAILED") != -1
    tags:
      - warningdays
      - 5.4.1.3
      - five
      - all

  - name: 5.4.1.3 - Ensure password expiration warning days is 7 or more
    shell: "grep ':$6' /etc/shadow | awk -F: '($6>'7' || $6<'7') && $6>='0' {print $1}'"
    register: echo
    when: warningdays.stdout.find("FAILED") != -1
    tags:
      - warningdays
      - 5.4.1.3
      - five
      - all

  - name: 5.4.1.3 - Ensure password expiration warning days is 7 or more
    chage: user="{{ item }}" sp_warn=7
    loop: "{{ echo.stdout_lines }}"
    when: 
      - warningdays.stdout.find("FAILED") != -1
      - item != "root"
    tags:
      - warningdays
      - 5.4.1.3
      - five
      - all

  - name:  5.4.1.4-Fetch the inactivepasswdlock  value from ansible facts
    shell: echo "{{ ansible_local.inactivepasswdlock_5414_audit }}"
    register: inactivepasswdlock
    ignore_errors: True
    tags:
      - inactivepasswdlock
      - 5.4.1.4
      - five
      - all

  - name: 5.4.1.4 - Ensure inactive password lock is 30 days or less
    shell: "useradd -D -f 30"
    when: inactivepasswdlock.stdout.find("FAILED") != -1
    tags:
      - inactivepasswdlock
      - 5.4.1.4
      - five
      - all

  - name: 5.4.1.4 - Ensure inactive password lock is 30 days or less
    shell: "grep '/home/' /etc/passwd | awk -F: '$3>=1000 {print $1}'"
    register: echo
    when: inactivepasswdlock.stdout.find("FAILED") != -1
    tags:
      - inactivepasswdlock
      - 5.4.1.4
      - five
      - all

  - name: 5.4.1.4 - Ensure inactive password lock is 30 days or less
    chage: user="{{ item }}" sp_inact=30
    loop: "{{ echo.stdout_lines }}"
    when: 
    - inactivepasswdlock.stdout.find("FAILED") != -1
    - item != "root"
    tags:
      - inactivepasswdlock
      - 5.4.1.4
      - five
      - all

  - name:  5.4.1.5-Fetch the lastpasswdchange  value from ansible facts
    shell: echo "{{ ansible_local.lastpasswdchange_5415_audit }}"
    register: lastpasswdchange
    ignore_errors: True
    tags:
      - lastpasswdchange
      - 5.4.1.5
      - five
      - all
      
  - name: 5.4.1.5 - Ensure all users last password change date is in the past
    shell: 'date +%s'
    register: now
    when: lastpasswdchange.stdout.find("FAILED") != -1
    tags:
      - lastpasswdchange
      - 5.4.1.5
      - five
      - all

  - name: 5.4.1.5 - Ensure all users last password change date is in the past
    shell: 'egrep ^[^:]+:[^\!*] /etc/shadow | cut -d: -f1'
    register: echo
    when: lastpasswdchange.stdout.find("FAILED") != -1
    tags:
      - lastpasswdchange
      - 5.4.1.5
      - five
      - all

  - name: 5.4.1.5 - Ensure all users last password change date is in the past
    shell: 'UPA=$(chage --list {{ item }} | grep "Last password change" | cut -d: -f2) && date -d "$UPA" +%s'
    loop: "{{ echo.stdout_lines }}"
    when: 
      - lastpasswdchange.stdout.find("FAILED") != -1
      - item != "root"
    register: epoch
    tags:
      - lastpasswdchange
      - 5.4.1.5
      - five
      - all

  - name: 5.4.1.5 - Ensure all users last password change date is in the past
    user:
      name: "{{ item }}"
      password_lock: yes
    loop: "{{ echo.stdout_lines }}"
    when: 
      - lastpasswdchange.stdout.find("FAILED") != -1
      - item != "root" and epoch|int >= now|int
    tags:
      - lastpasswdchange
      - 5.4.1.5
      - five
      - all

  - name:  5.4.2-Fetch the  sysaccnonlogin value from ansible facts
    shell: echo "{{ ansible_local.sysaccnonlogin_542_audit }}"
    register: sysaccnonlogin
    ignore_errors: True
    tags:
      - sysaccnonlogin
      - 5.4.2
      - five
      - all
      
  - name: 5.4.2 - Ensure system accounts are secured
    shell: "awk -F: '$3<1000 && $7!= '/sbin/nologin' {print $1 }' /etc/passwd"
    register: echo
    when: sysaccnonlogin.stdout.find("FAILED") != -1
    tags:
      - sysaccnonlogin
      - 5.4.2
      - five
      - all

  - name: 5.4.2 - Ensure system accounts are secured
    user:
      name: "{{ item }}"
      password_lock: yes
    loop: "{{ echo.stdout_lines }}"
    when:
      - sysaccnonlogin.stdout.find("FAILED") != -1
      - item != "root"
    tags:
      - sysaccnonlogin
      - 5.4.2
      - five
      - all

  - name: 5.4.2 - Ensure system accounts are secured
    user:
      name: "{{ item }}"
      shell: '/sbin/nologin'
    loop: "{{ echo.stdout_lines }}"
    when: 
    - sysaccnonlogin.stdout.find("FAILED") != -1
    - item != "root" and item != "sync" and item != "shutdown" and item != "halt"
    tags:
      - sysaccnonlogin
      - 5.4.2
      - five
      - all

  - name:  5.4.3-Fetch the defaultgroup  value from ansible facts
    shell: echo "{{ ansible_local.defaultgroup_543_audit }}"
    register: defaultgroup
    ignore_errors: True
    tags:
      - defaultgroup
      - 5.4.3
      - five
      - all
      
  - name: 5.4.3 - Ensure default group for the root account is GID 0
    user:
      name: root
      groups: root
    when: defaultgroup.stdout.find("FAILED") != -1  
    tags:
      - defaultgroup
      - 5.4.3
      - five
      - all

  - name:  5.4.4-Fetch the usershelltimeout  value from ansible facts
    shell: echo "{{ ansible_local.usershelltimeout_544_audit }}"
    register: usershelltimeout
    ignore_errors: True
    tags:
      - usershelltimeout
      - 5.4.4
      - five
      - all
      
  - name: 5.4.4 Ensure default user shell timeout is configured 
    lineinfile:
      path: /etc/bashrc
      state: present
      line: 'TMOUT=600'
    failed_when: no
    when: usershelltimeout.stdout.find("FAILED") != -1    
    tags:
      - usershelltimeout
      - 5.4.4
      - five
      - all

  - name: 5.4.4 Ensure default user shell timeout is configured
    lineinfile:
      path: /etc/profile
      state: present
      line: 'TMOUT=600'
    failed_when: no
    when: usershelltimeout.stdout.find("FAILED") != -1   
    tags:
      - usershelltimeout
      - 5.4.4
      - five
      - all

  - name:  5.4.5-Fetch the defaultuser  value from ansible facts
    shell: echo "{{ ansible_local.defaultuser_545_audit }}"
    register: defaultuser
    ignore_errors: True
    tags:
      - defaultuser
      - 5.4.5
      - five
      - all

  - name: 5.4.5 Ensure default user umask is configured
    lineinfile:
      path: /etc/bashrc
      state: present
      line: "umask 027" 
    failed_when: no
    when: defaultuser.stdout.find("FAILED") != -1  
    tags:
      - defaultuser
      - 5.4.5
      - five
      - all

  - name: 5.4.5 - Ensure default user umask is 027 or more restrictive
    lineinfile:
      path: /etc/profile
      state: present
      line: "umask 027"
    failed_when: no
    when: defaultuser.stdout.find("FAILED") != -1  
    tags:
      - defaultuser
      - 5.4.5
      - five
      - all

  - name:  5.5-Fetch the rootlogin  value from ansible facts
    shell: echo "{{ ansible_local.rootlogin_55_audit }}"
    register: rootlogin
    ignore_errors: True
    tags:
      - rootlogin
      - '5.5'
      - five
      - all
      
  - name: 5.5 - Ensure root login is restricted to system console
    shell: sed -i '/^tty/!d'  /etc/securetty
    when: rootlogin.stdout.find("FAILED") != -1   
    tags:
      - rootlogin
      - '5.5'
      - five
      - all

  - name: 5.6-Fetch the  suaccess value from ansible facts
    shell: echo "{{ ansible_local.suaccess_56_audit }}"
    register: suaccess
    ignore_errors: True
    tags:
      - suaccess
      - '5.6'
      - five
      - all
      
  - name: 5.6 - Ensure access to the su command is restricted 
    replace:
      path: /etc/pam.d/su
      regexp: '^#(auth.*required.*pam_wheel.so.*)'
      replace: '\1'
    failed_when: no
    when: suaccess.stdout.find("FAILED") != -1   
    tags:
      - suaccess
      - '5.6'
      - five
      - all

  - name: 5.6 - Ensure access to the su command is restricted
    lineinfile:
      path: /etc/pam.d/su
      state: present
      regexp: '^(auth.*required.*pam_wheel.so.*)$'
      line: '\1 group=sugroup'
      backrefs: yes
    when: suaccess.stdout.find("FAILED") != -1   
    tags:
      - suaccess
      - '5.6'
      - five
      - all

  - name:  6.1.1-Fetch the  auditsysperm value from ansible facts
    shell: echo "{{ ansible_local.auditsysperm_611_audit }}" 
    register: auditsysperm
    ignore_errors: True
    tags:
      - auditsysperm
      - 6.1.1
      - six
      - all
 
  - name: 6.1.1 - Audit system file permissions
    shell: "rpm -Va --nomtime --nosize --nomd5 --nolinkto"
    register: eho
    ignore_errors: yes
    when: auditsysperm.stdout.find("FAILED") != -1
    tags:
      - auditsysperm
      - 6.1.1
      - six
      - all

  - name: 6.1.1 - Audit system file permissions
    shell: "rpm -qf {{ item }} 2>/dev/null "
    loop: "{{ eho.stdout_lines }}"
    ignore_errors: yes
    when: auditsysperm.stdout.find("FAILED") != -1
    tags:
      - auditsysperm
      - 6.1.1
      - six
      - all

  - name:  6.1.2-Fetch the permpasswd  value from ansible facts
    shell: echo "{{ ansible_local.permpasswd_612_audit }}"
    register: permpasswd
    ignore_errors: True
    tags:
      - permpasswd
      - 6.1.2
      - six
      - all

  - name: 6.1.2 - Ensure permissions on /etc/passwd are configured
    file:
      path: "/etc/passwd"
      state: touch
      mode: 0644
      owner: root
      group: root
    when: permpasswd.stdout.find("FAILED") != -1
    tags:
      - permpasswd
      - 6.1.2
      - six
      - all

  - name:  6.1.3-Fetch the permshadow  value from ansible facts
    shell: echo "{{ ansible_local.permshadow_613_audit }}" 
    register: permshadow
    ignore_errors: True
    tags:
      - permshadow
      - 6.1.3
      - six
      - all

  - name: 6.1.3 - Ensure permissions on /etc/shadow are configured
    file:
      path: "/etc/shadow"
      state: touch
      mode: 0000
      owner: root
      group: root
    when: permshadow.stdout.find("FAILED") != -1
    tags:
      - permshadow
      - 6.1.3
      - six
      - all

  - name:  6.1.4-Fetch the permgroup  value from ansible facts
    shell: echo "{{ ansible_local.permgroup_614_audit }}" 
    register: permgroup
    ignore_errors: True
    tags:
      - permgroup
      - 6.1.4
      - six
      - all
  
  - name: 6.1.4 - Ensure permissions on /etc/group are configured
    file:
      path: "/etc/group"
      state: touch
      mode: 0644
      owner: root
      group: root
    when: permgroup.stdout.find("FAILED") != -1
    tags:
      - permgroup
      - 6.1.4
      - six
      - all

  - name:  6.1.5-Fetch the  permgshadow value from ansible facts
    shell: echo "{{ ansible_local.permgshadow_615_audit }}" 
    register: permgshadow
    ignore_errors: True
    tags:
      - permgshadow
      - 6.1.5
      - six
      - all

  - name: 6.1.5 - Ensure permissions on /etc/gshadow are configured
    file:
      path: "/etc/gshadow"
      state: touch
      mode: 0000
      owner: root
      group: root
    when: permgshadow.stdout.find("FAILED") != -1
    tags:
      - permgshadow
      - 6.1.5
      - six
      - all

  - name:  6.1.6-Fetch the  permpasswdi value from ansible facts
    shell: echo "{{ ansible_local.permpasswdi_616_audit }}" 
    register: permpasswdi
    ignore_errors: True
    tags:
      - permpasswdi
      - 6.1.6
      - six
      - all

  - name: 6.1.6 - Ensure permissions on /etc/passwd- are configured
    file:
      path: "/etc/passwd-"
      state: touch
      mode: 0644
      owner: root
      group: root
    when: permpasswdi.stdout.find("FAILED") != -1
    tags:
      - permpasswdi
      - 6.1.6
      - six
      - all

  - name:  6.1.7-Fetch the  permshadowi value from ansible facts
    shell: echo "{{ ansible_local.permshadowi_617_audit }}" 
    register: permshadowi
    ignore_errors: True
    tags:
      - permshadowi
      - 6.1.7
      - six
      - all

  - name: 6.1.7 - Ensure permissions on /etc/shadow- are configured
    file:
      path: "/etc/shadow-"
      state: touch
      mode: 0000
      owner: root
      group: root
    when: permshadowi.stdout.find("FAILED") != -1
    tags:
      - permshadowi
      - 6.1.7
      - six
      - all

  - name:  6.1.8-Fetch the permgroupi  value from ansible facts
    shell: echo "{{ ansible_local.permgroupi_618_audit }}" 
    register: permgroupi
    ignore_errors: True
    tags:
      - permgroupi
      - 6.1.8
      - six
      - all

  - name: 6.1.8 - Ensure permissions on /etc/group- are configured
    file:
      path: "/etc/group-"
      state: touch
      mode: 0644
      owner: root
      group: root
    when: permgroupi.stdout.find("FAILED") != -1
    tags:
      - permgroupi
      - 6.1.8
      - six
      - all

  - name:  6.1.9-Fetch the  permgshadowi value from ansible facts
    shell: echo "{{ ansible_local.permgshadowi_619_audit }}"
    register: permgshadowi
    ignore_errors: True
    tags:
      - permgshadowi
      - 6.1.9
      - six
      - all

  - name: 6.1.9 - Ensure permissions on /etc/gshadow- are configured
    file:
      path: "/etc/gshadow-"
      state: touch
      mode: 0000
      owner: root
      group: root
    when: permgshadowi.stdout.find("FAILED") != -1
    tags:
      - permgshadowi
      - 6.1.9
      - six
      - all

  - name:  6.1.10-Fetch the wwfiles  value from ansible facts
    shell: echo "{{ ansible_local.wwfiles_6110_audit }}" 
    register: wwfiles
    ignore_errors: True
    tags:
      - wwfiles
      - 6.1.10
      - six
      - all

  - name: 6.1.10 - Ensure no world writable files exist
    shell: "df --local -P | awk {'if (NR!=1) print $6'} | xargs -I '{}' find '{}' -xdev -type f -perm -0002"
    register: echo
    when: wwfiles.stdout.find("FAILED") != -1
    tags:
      - wwfiles
      - 6.1.10
      - six
      - all

  - name: 6.1.10 - Ensure no world writable files exist
    file:
      path: "{{ item }}"
      mode: o-w
    loop: "{{ echo.stdout_lines }}"
    when: wwfiles.stdout.find("FAILED") != -1
    tags:
      - wwfiles
      - 6.1.10
      - six
      - all

  - name:   6.1.11-Fetch the unownedfiles  value from ansible facts
    shell: echo "{{ ansible_local.unownedfiles_6111_audit }}" 
    register: unownedfiles
    ignore_errors: True
    tags:
      - unownedfiles
      - 6.1.11
      - six
      - all

  - name: 6.1.11 Ensure no unowned files or directories exist
    shell: "df --local -P | awk {'if (NR!=1) print $6'} | xargs -I '{}' find '{}' -xdev -nouser"
    register: echo
    when: unownedfiles.stdout.find("FAILED") != -1
    tags:
      - unownedfiles
      - 6.1.11
      - six
      - all

  - name: 6.1.11 Ensure no unowned files or directories exist
    file:
      path: "{{ item }}"
      owner: root
      group: root
    loop: "{{ echo.stdout_lines }}"
    when: unownedfiles.stdout.find("FAILED") != -1
    tags:
      - unownedfiles
      - 6.1.11
      - six
      - all

  - name: 6.1.11 Ensure no unowned files or directories exist
    shell: "find / -xdev -nouser"
    register: echo
    when: unownedfiles.stdout.find("FAILED") != -1
    tags:
      - unownedfiles
      - 6.1.11
      - six
      - all

  - name: 6.1.11 Ensure no unowned files or directories exist
    file:
      path: "{{ item }}"
      owner: root
      group: root
    loop: "{{ echo.stdout_lines }}"
    when: unownedfiles.stdout.find("FAILED") != -1
    tags:
      - unownedfiles
      - 6.1.11
      - six
      - all

  - name:  6.1.12-Fetch the ungroupedfiles  value from ansible facts
    shell: echo "{{ ansible_local.ungroupedfiles_6112_audit }}" 
    register: ungroupedfiles
    ignore_errors: True
    tags:
      - ungroupedfiles
      - 6.1.12
      - six
      - all

  - name: 6.1.12 - Ensure no ungrouped files or directories exist
    shell: "df --local -P | awk {'if (NR!=1) print $6'} | xargs -I '{}' find '{}' -xdev -nogroup"
    register: echo
    when: ungroupedfiles.stdout.find("FAILED") != -1
    tags:
      - ungroupedfiles
      - 6.1.12
      - six
      - all

  - name: 6.1.12 - Ensure no ungrouped files or directories exist
    file:
      path: "{{ item }}"
      owner: root
      group: root
    loop: "{{ echo.stdout_lines }}"
    when: ungroupedfiles.stdout.find("FAILED") != -1
    tags:
      - ungroupedfiles
      - 6.1.12
      - six
      - all

  - name: 6.1.12 - Ensure no ungrouped files or directories exist
    shell: "find / -xdev -nogroup"
    register: echo
    when: ungroupedfiles.stdout.find("FAILED") != -1
    tags:
      - ungroupedfiles
      - 6.1.12
      - six
      - all

  - name: 6.1.12 - Ensure no ungrouped files or directories exist
    file:
      path: "{{ item }}"
      owner: root
      group: root
    loop: "{{ echo.stdout_lines }}"
    when: ungroupedfiles.stdout.find("FAILED") != -1
    tags:
      - ungroupedfiles
      - 6.1.12
      - six
      - all

  - name:  6.2.1-Fetch the   value from ansible facts 
    shell: echo "{{ ansible_local.useshadowed_621_audit }}" 
    register: useshadowed
    ignore_errors: True
    tags:
      - useshadowed
      - 6.2.1
      - six
      - all

  - name: 6.2.1 - Ensure  accounts in /etc/passwd use shadowed passwords 
    shell: sed -e 's/^\([a-zA-Z0-9_]*\):[^:]*:/\1:x:/' -i /etc/passwd
    when: useshadowed.stdout.find("FAILED") != -1
    tags:
      - useshadowed
      - 6.2.1
      - six
      - all

  - name:  6.2.2-Fetch the emptypasswd  value from ansible facts
    shell: echo "{{ ansible_local.emptypasswd_622_audit }}" 
    register: emptypasswd
    ignore_errors: True
    tags:
      - emptypasswd
      - 6.2.2
      - six
      - all

  - name: 6.2.2 - Ensure /etc/shadow password fields are not empty
    shell: "grep '/home' /etc/passwd | awk  -F: '$3>=1000 {print $1}'"
    register: echo
    when: emptypasswd.stdout.find("FAILED") != -1
    tags:
      - emptypasswd
      - 6.2.2
      - six
      - all

  - name: 6.2.2 - Ensure /etc/shadow password fields are not empty
    shell: "grep '{{ echo.stdout }}' /etc/shadow | awk -F':' '$2==\"\" {print $1}'"
    register: ech
    when: emptypasswd.stdout.find("FAILED") != -1
    tags:
      - emptypasswd
      - 6.2.2
      - six
      - all

  - name: 6.2.2 - Ensure /etc/shadow password fields are not empty
    user:
      name: "{{ item }}"
      password_lock: yes
    loop: "{{ ech.stdout_lines }}"
    when: emptypasswd.stdout.find("FAILED") != -1
    tags:
      - emptypasswd
      - 6.2.2
      - six
      - all

  - name:  6.2.3-Fetch the  rootuid value from ansible facts
    shell: echo "{{ ansible_local.rootuid_623_audit }}" 
    register: rootuid
    ignore_errors: True
    tags:
      - rootuid
      - 6.2.3
      - six
      - all

  - name: 6.2.3 - Ensure root is the only UID 0 account
    shell: |
       for a in $(cat /etc/passwd | awk -F: '$3==0 {print $1}'); do
       b=$(grep '/home/' /etc/passwd | cut -d':' -f3 | sort -n | tail -n 1)
       testuid=$(( $b+1 ))
       echo $testuid
           if [ "$a" != "root" ]; then
              sed -i '/'$a'/s/\:0\:/:'$testuid':/g' /etc/passwd
           fi
       done
    when: rootuid.stdout.find("FAILED") != -1 
    tags:
      - rootuid
      - 6.2.3
      - six
      - all

  - name:  6.2.5-Fetch the userhdir  value from ansible facts
    shell: echo "{{ ansible_local.userhdir_625_audit }}" 
    register: userhdir
    ignore_errors: True
    tags:
      - userhdir
      - 6.2.5
      - six
      - all

  - name: 6.2.5 - Ensure all users' home directories exist
    shell: "grep '/home/' /etc/passwd | awk -F: '$3>=1000 && $7!=/sbin/nologin && $7!=/bin/false {print $1}'"
    register: echo
    when: userhdir.stdout.find("FAILED") != -1
    tags:
      - userhdir
      - 6.2.5
      - six
      - all

  - name: 6.2.5 - Ensure all users' home directories exist
    file:
      path: "/home/{{ item }}"
      state: directory
      mode: 0700
      owner: "{{ item }}"
      group: "{{ item }}"
    loop: "{{ echo.stdout_lines }}"
    when: userhdir.stdout.find("FAILED") != -1
    tags:
      - userhdir
      - 6.2.5
      - six
      - all

  - name:  6.2.6-Fetch the userhdirperm  value from ansible facts
    shell: echo "{{ ansible_local.userhdirperm_626_audit }}" 
    register: userhdirperm
    ignore_errors: True
    tags:
      - userhdirperm
      - 6.2.6
      - six
      - all

  - name: 6.2.6 - Ensure users' home directories permissions are 750 or more restrictive
    shell: "cat /etc/passwd | awk -F: '($3>=1000 && $7 != '/sbin/nologin' && $7 != '/bin/false') { print $1 }' | sort"
    register: echo
    when: userhdirperm.stdout.find("FAILED") != -1
    tags:
      - userhdirperm
      - 6.2.6
      - six
      - all

  - name: 6.2.6 - Ensure users' home directories permissions are 750 or more restrictive
    file:
      path: "/home/{{ item }}"
      state: directory
      mode: 0700
    loop: "{{ echo.stdout_lines }}"
    when: userhdirperm.stdout.find("FAILED") != -1
    tags:
      - userhdirperm
      - 6.2.6
      - six
      - all

  - name:  6.2.7-Fetch the userownhdir  value from ansible facts
    shell: echo "{{ ansible_local.userownhdir_627_audit }}" 
    register: userownhdir
    ignore_errors: True
    tags:
      - userownhdir
      - 6.2.7
      - six
      - all

  - name: 6.2.7 - Ensure users own their home directories
    shell: |
       cat /etc/passwd | awk -F: '{ print $1 " " $3 " " $6 }' | grep -v 'root 0 /root' | while read user uid dir; do
       if [ $uid -ge 1000 -a -d "$dir" -a $user != "nfsnobody" ]; then
             owner=$(stat -L -c "%U" "$dir")
             if [ "$owner" != "$user" ]; then
                 echo "$dir:$user:$owner" >> /tmp/cisuserhdir
             fi
       fi
       done
          a=$(sed -i 's/\/:nobody.*//g' /tmp/cisuserhdir)
          b=$(cat /tmp/cisuserhdir | grep -v '^[[:space:]]*$')
          echo "$b"
          rm -rf /tmp/cisuserhdir
    register: userhdirreg
    when: userownhdir.stdout.find("FAILED") != -1
    tags:
      - userownhdir
      - 6.2.7
      - six
      - all

  - name: 6.2.7 - Ensure users own their home directories
    file:
      path: "{{ item.split(':')[0] }}"
      owner: "{{ item.split(':')[1] }}"
      group: "{{ item.split(':')[1] }}"
    loop: "{{ userhdirreg.stdout_lines }}"
    when: userownhdir.stdout.find("FAILED") != -1
    tags:
      - userownhdir
      - 6.2.7
      - six
      - all

  - name:  6.2.8-Fetch the dotfiles  value from ansible facts
    shell: echo "{{ ansible_local.dotfiles_628_audit }}" 
    register: dotfiles
    ignore_errors: True
    tags:
      - dotfiles
      - 6.2.8
      - six
      - all
   
  - name: 6.2.8 - Ensure users' dot files are not group or world writable
    shell: "find /home/ -name '.[A-Za-z0-9]*' -perm /g+w,o+w"
    register: echo
    when: dotfiles.stdout.find("FAILED") != -1
    tags:
      - dotfiles
      - 6.2.8
      - six
      - all

  - name: 6.2.8 - Ensure users' dot files are not group or world writable
    file:
      path: "{{ item }}"
      mode: "go-w"
    loop: "{{ echo.stdout_lines }}"
    when: dotfiles.stdout.find("FAILED") != -1
    tags:
      - dotfiles
      - 6.2.8
      - six
      - all

  - name:  6.2.9-Fetch the  forwardfiles value from ansible facts
    shell: echo "{{ ansible_local.forwardfiles_629_audit }}" 
    register: forwardfiles
    ignore_errors: True
    tags:
      - forwardfiles
      - 6.2.9
      - six
      - all
 
  - name: 6.2.9 - Ensure no users have .forward files
    shell: "find / -type f -name '*.forward' 2> /dev/null"
    register: echo
    when: forwardfiles.stdout.find("FAILED") != -1
    tags:
      - forwardfiles
      - 6.2.9
      - six
      - all

  - name: 6.2.9 - Ensure no users have .forward files
    file:
      path: "{{ item }}"
      state: absent
    loop: "{{ echo.stdout_lines }}"
    when: forwardfiles.stdout.find("FAILED") != -1
    tags:
      - forwardfiles
      - 6.2.9
      - six
      - all

  - name:  6.2.10-Fetch the  netrcfiles value from ansible facts
    shell: echo "{{ ansible_local.netrcfiles_6210_audit }}" 
    register: netrcfiles
    ignore_errors: True
    tags:
      - netrcfiles
      - 6.2.10
      - six
      - all

  - name: 6.2.10 - Ensure no users have .netrc files
    shell: "find / -name '.netrc' 2> /dev/null"
    register: echo
    when: netrcfiles.stdout.find("FAILED") != -1
    tags:
      - netrcfiles
      - 6.2.10
      - six
      - all

  - name: 6.2.10 - Ensure no users have .netrc files
    file:
      path: "{{ item }}"
      state: absent
    loop: "{{ echo.stdout_lines }}"
    when: netrcfiles.stdout.find("FAILED") != -1
    tags:
      - netrcfiles
      - 6.2.10
      - six
      - all

  - name:  6.2.11-Fetch the  grpnetrcfiles value from ansible facts
    shell: echo "{{ ansible_local.grpnetrcfiles_6211_audit }}" 
    register: grpnetrcfiles
    ignore_errors: True
    tags:
      - grpnetrcfiles
      - 6.2.11
      - six
      - all

  - name: 6.2.11 - Ensure users' .netrc Files are not group or world writable
    shell: "find /home/ -name '.netrc' -perm /g+w,o+w"
    register: echo
    when: grpnetrcfiles.stdout.find("FAILED") != -1
    tags:
      - grpnetrcfiles
      - 6.2.11
      - six
      - all

  - name: 6.2.11 - Ensure users' .netrc Files are not group or world writable
    file:
      path: "{{ item }}"
      mode: "go-w"
    loop: "{{ echo.stdout_lines }}"
    when: grpnetrcfiles.stdout.find("FAILED") != -1
    tags:
      - grpnetrcfiles
      - 6.2.11
      - six
      - all

  - name:  6.2.12-Fetch the rhosts  value from ansible facts
    shell: echo "{{ ansible_local.rhosts_6212_audit }}"
    register: rhosts
    ignore_errors: True
    tags:
      - rhosts
      - 6.2.12
      - six
      - all

  - name: 6.2.12 - Ensure no users have .rhosts files
    shell: "find /home -name '.rhosts' | wc -l"
    register: echo
    when: rhosts.stdout.find("FAILED") != -1
    tags:
      - rhosts
      - 6.2.12
      - six
      - all

  - name: 6.2.12 - Ensure no users have .rhosts files
    file:
      path: "{{ item }}"
      state: absent
    loop: "{{ echo.stdout_lines }}"
    when: rhosts.stdout.find("FAILED") != -1
    tags:
      - rhosts
      - 6.2.12
      - six
      - all

  - name:  6.2.13-Fetch the  groups value from ansible facts
    shell: echo "{{ ansible_local.groups_6213_audit }}"
    register: group
    ignore_errors: True
    tags:
      - groups
      - 6.2.13
      - six
      - all

  - name: 6.2.13 - Ensure all groups in /etc/passwd exist in /etc/group
    shell: |
        for i in $(cut -s -d: -f4 /etc/passwd | sort -u ); do
        grep -q -P "^.*?:[^:]*:$i:" /etc/group
            if [ $? -ne 0 ]; then
              a=$(grep $i /etc/passwd | awk -F: '{print $1}')
              groupadd $a
              usermod -g $a $a
            fi
        done
    when: group.stdout.find("FAILED") != -1
    tags:
      - groups
      - 6.2.13
      - six
      - all

  - name:  6.2.14-Fetch the  duplicateuid value from ansible facts
    shell: echo "{{ ansible_local.duplicateuid_6214_audit }}" 
    register: duplicateuid
    ignore_errors: True
    tags:
      - duplicateuid
      - 6.2.14
      - six
      - all

  - name: 6.2.14 - Ensure no duplicate UIDs exist
    shell: "awk -F: '$3>=1000 {print $3}' /etc/passwd | sort | uniq -c | awk '$1 > 1 {print $2}'"
    register: echo
    when: duplicateuid.stdout.find("FAILED") != -1
    tags:
      - duplicateuid
      - 6.2.14
      - six
      - all

  - name: 6.2.14 - Ensure no duplicate UIDs exist
    shell: "a=$(awk -F: '$3>=1000 {print $3}' /etc/passwd | sort | uniq -c | awk '$1 > 1 {print $2}') && grep $a /etc/passwd | awk -F: '{print $1}'| awk 'FNR != 1' || true"
    register: user
    when:
      - duplicateuid.stdout.find("FAILED") != -1 
      - echo.stdout != ""
    tags:
      - duplicateuid
      - 6.2.14
      - six
      - all

  - name: 6.2.14 - Ensure no duplicate UIDs exist
    shell: "b=$(grep '/home/' /etc/passwd | cut -d':' -f3 |  sort -n | tail -n 1) && c=$(( $b+1 )) && echo $c || true"
    register: val
    when:
      - duplicateuid.stdout.find("FAILED") != -1
      - echo.stdout != ""
    tags:
      - duplicateuid
      - 6.2.14
      - six
      - all

  - name: 6.2.14 - Ensure no duplicate UIDs exist
    user:
      name: "{{ user.stdout }}"
      uid: "{{ val.stdout }}"
    loop: "{{ echo.stdout_lines }}"
    when:
      - duplicateuid.stdout.find("FAILED") != -1 
      - item != ""
    tags:
      - duplicateuid
      - 6.2.14
      - six
      - all

  - name:  6.2.15-Fetch the duplicategid  value from ansible facts
    shell: echo "{{ ansible_local.duplicategid_6215_audit }}" 
    register: duplicategid
    ignore_errors: True
    tags:
      - duplicategid
      - 6.2.15
      - six
      - all

  - name: 6.2.15 - Ensure no duplicate GIDs exist
    shell: "cat /etc/group | cut -f3 -d':' | sort | uniq -c | awk '$1 > 1 {print $2}'"
    register: echo
    when: duplicategid.stdout.find("FAILED") != -1
    tags:
      - duplicategid
      - 6.2.15
      - six
      - all

  - name: 6.2.15 - Ensure no duplicate GIDs exist
    shell: "a=$(cat /etc/group | cut -f3 -d':' | sort | uniq -c | awk '$1 > 1 {print $2}') && grep $a /etc/group | awk -F: '{print $1}'| awk 'FNR != 1'"
    register: user
    when:
      - duplicategid.stdout.find("FAILED") != -1 
      - echo.stdout != ""
    tags:
      - duplicategid
      - 6.2.15
      - six
      - all

  - name: 6.2.15 - Ensure no duplicate GIDs exist
    shell: "b=$(cut -f 3 -d: /etc/group | awk '$1<5000 {print $1}' | sort -n | tail -n 1) && c=$(($b+1)) && echo $c"
    register: val
    when:
      - duplicategid.stdout.find("FAILED") != -1 
      - echo.stdout != ""
    tags:
      - duplicategid
      - 6.2.15
      - six
      - all

  - name: 6.2.15 - Ensure no duplicate GIDs exist
    group:
      name: "{{ user.stdout }}"
      gid: "{{ val.stdout }}"
    loop: "{{ echo.stdout_lines }}"
    when:
      - duplicategid.stdout.find("FAILED") != -1 
      - item != ""
    tags:
      - duplicategid
      - 6.2.15
      - six
      - all

  - name:  6.2.16-Fetch the  duplicateuser value from ansible facts
    shell: echo "{{ ansible_local.duplicateuser_6216_audit }}" 
    register: duplicateuser
    ignore_errors: True
    tags:
      - duplicateuser
      - 6.2.16
      - six
      - all

  - name: 6.2.16 - Ensure no duplicate user names exist
    shell: "cat /etc/passwd | cut -f1 -d':' | sort | uniq -c | awk '$1 > 1 {print $2}'"
    register: echo
    when: duplicateuser.stdout.find("FAILED") != -1
    tags:
      - duplicateuser
      - 6.2.16
      - six
      - all

  - name: 6.2.16 - Ensure no duplicate user names exist
    shell: "a=$(cat /etc/passwd | cut -f1 -d':' | sort | uniq -c | awk '$1 > 1 {print $2}') && grep $a /etc/passwd | awk -F: '{print $1}'| awk 'FNR != 1'"
    register: val
    when:
      - duplicateuser.stdout.find("FAILED") != -1 
      - echo.stdout != ""
    tags:
      - duplicateuser
      - 6.2.16
      - six
      - all

  - name: 6.2.16 - Ensure no duplicate user names exist
    debug:
      msg: "{{ val.stdout }}"
    loop: "{{ echo.stdout_lines }}"
    when:
      - duplicateuser.stdout.find("FAILED") != -1 
      - item != ""
    tags:
      - duplicateuser
      - 6.2.16
      - six
      - all

  - name:  6.2.17-Fetch the duplicategroup  value from ansible facts
    shell: echo "{{ ansible_local.duplicategroup_6217_audit }}" 
    register: duplicategroup
    ignore_errors: True
    tags:
      - duplicategroup
      - 6.2.17
      - six
      - all
 
  - name: 6.2.17 - Ensure no duplicate group names exist
    shell: "cat /etc/group | cut -f1 -d':' | sort | uniq -c | awk '$1 > 1 {print $2}'"
    register: echo
    when: duplicategroup.stdout.find("FAILED") != -1
    tags:
      - duplicategroup
      - 6.2.17
      - six
      - all

  - name: 6.2.17 - Ensure no duplicate group names exist
    shell: "a=$(cat /etc/group | cut -f1 -d':' | sort | uniq -c | awk '$1 > 1 {print $2}') && grep $a /etc/group | awk -F: '{print $1}' | awk 'FNR != 1'"
    register: val
    when:
      - duplicategroup.stdout.find("FAILED") != -1 
      - echo.stdout != ""
    tags:
      - duplicategroup
      - 6.2.17
      - six
      - all

  - name: 6.2.17 - Ensure no duplicate group names exist
    debug:
      msg: "{{ val.stdout }}"
    loop: "{{ echo.stdout_lines }}"
    when:
      - duplicategroup.stdout.find("FAILED") != -1 
      - item != ""
    tags:
      - duplicategroup
      - 6.2.17
      - six
      - all

  - name:  6.2.18-Fetch the shadowgroup  value from ansible facts
    shell: echo "{{ ansible_local.shadowgroup_6218_audit }}"
    register: shadowgroup
    ignore_errors: True
    tags:
      - shadowgroup
      - 6.2.18
      - six
      - all
      
  - name: 6.2.18 - Ensure shadow group is empty
    shell: |
       a=$(cat /etc/group | grep "^shadow" | awk -F: '{print $3}')
       if [ $(cat /etc/group | grep "^shadow" | wc -l) -gt 0 ]; then
           for i in $(cat /etc/passwd | cut -d, -f1-3 | grep "$a" | awk -F: '{print $1}'); do
              usermod -g users $i
            done
       fi
    failed_when: no
    when: shadowgroup.stdout.find("FAILED") != -1
    tags:
      - shadowgroup
      - 6.2.18
      - six
      - all
